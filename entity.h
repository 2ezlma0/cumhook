#pragma once

#define MAX_WEAPONS	48

enum animstate_layer_t {
	ANIMATION_LAYER_AIMMATRIX = 0,
	ANIMATION_LAYER_WEAPON_ACTION,
	ANIMATION_LAYER_WEAPON_ACTION_RECROUCH,
	ANIMATION_LAYER_ADJUST,
	ANIMATION_LAYER_MOVEMENT_JUMP_OR_FALL,
	ANIMATION_LAYER_MOVEMENT_LAND_OR_CLIMB,
	ANIMATION_LAYER_MOVEMENT_MOVE,
	ANIMATION_LAYER_MOVEMENT_STRAFECHANGE,
	ANIMATION_LAYER_WHOLE_BODY,
	ANIMATION_LAYER_FLASHED,
	ANIMATION_LAYER_FLINCH,
	ANIMATION_LAYER_ALIVELOOP,
	ANIMATION_LAYER_LEAN,
	ANIMATION_LAYER_COUNT,
};

enum ClassID {
	CAI_BaseNPC,
	CAK47,
	CBaseAnimating,
	CBaseAnimatingOverlay,
	CBaseAttributableItem,
	CBaseButton,
	CBaseCombatCharacter,
	CBaseCombatWeapon,
	CBaseCSGrenade,
	CBaseCSGrenadeProjectile,
	CBaseDoor,
	CBaseEntity,
	CBaseFlex,
	CBaseGrenade,
	CBaseParticleEntity,
	CBasePlayer,
	CBasePropDoor,
	CBaseTeamObjectiveResource,
	CBaseTempEntity,
	CBaseToggle,
	CBaseTrigger,
	CBaseViewModel,
	CBaseVPhysicsTrigger,
	CBaseWeaponWorldModel,
	CBeam,
	CBeamSpotlight,
	CBoneFollower,
	CBreakableProp,
	CBreakableSurface,
	CC4,
	CCascadeLight,
	CChicken,
	CColorCorrection,
	CColorCorrectionVolume,
	CCSGameRulesProxy,
	CCSPlayer,
	CCSPlayerResource,
	CCSRagdoll,
	CCSTeam,
	CDEagle,
	CDecoyGrenade,
	CDecoyProjectile,
	CDynamicLight,
	CDynamicProp,
	CEconEntity,
	CEconWearable,
	CEmbers,
	CEntityDissolve,
	CEntityFlame,
	CEntityFreezing,
	CEntityParticleTrail,
	CEnvAmbientLight,
	CEnvDetailController,
	CEnvDOFController,
	CEnvParticleScript,
	CEnvProjectedTexture,
	CEnvQuadraticBeam,
	CEnvScreenEffect,
	CEnvScreenOverlay,
	CEnvTonemapController,
	CEnvWind,
	CFEPlayerDecal,
	CFireCrackerBlast,
	CFireSmoke,
	CFireTrail,
	CFish,
	CFlashbang,
	CFogController,
	CFootstepControl,
	CFunc_Dust,
	CFunc_LOD,
	CFuncAreaPortalWindow,
	CFuncBrush,
	CFuncConveyor,
	CFuncLadder,
	CFuncMonitor,
	CFuncMoveLinear,
	CFuncOccluder,
	CFuncReflectiveGlass,
	CFuncRotating,
	CFuncSmokeVolume,
	CFuncTrackTrain,
	CGameRulesProxy,
	CHandleTest,
	CHEGrenade,
	CHostage,
	CHostageCarriableProp,
	CIncendiaryGrenade,
	CInferno,
	CInfoLadderDismount,
	CInfoOverlayAccessor,
	CItem_Healthshot,
	CItemDogtags,
	CKnife,
	CKnifeGG,
	CLightGlow,
	CMaterialModifyControl,
	CMolotovGrenade,
	CMolotovProjectile,
	CMovieDisplay,
	CParticleFire,
	CParticlePerformanceMonitor,
	CParticleSystem,
	CPhysBox,
	CPhysBoxMultiplayer,
	CPhysicsProp,
	CPhysicsPropMultiplayer,
	CPhysMagnet,
	CPlantedC4,
	CPlasma,
	CPlayerResource,
	CPointCamera,
	CPointCommentaryNode,
	CPointWorldText,
	CPoseController,
	CPostProcessController,
	CPrecipitation,
	CPrecipitationBlocker,
	CPredictedViewModel,
	CProp_Hallucination,
	CPropDoorRotating,
	CPropJeep,
	CPropVehicleDriveable,
	CRagdollManager,
	CRagdollProp,
	CRagdollPropAttached,
	CRopeKeyframe,
	CSCAR17,
	CSceneEntity,
	CSensorGrenade,
	CSensorGrenadeProjectile,
	CShadowControl,
	CSlideshowDisplay,
	CSmokeGrenade,
	CSmokeGrenadeProjectile,
	CSmokeStack,
	CSpatialEntity,
	CSpotlightEnd,
	CSprite,
	CSpriteOriented,
	CSpriteTrail,
	CStatueProp,
	CSteamJet,
	CSun,
	CSunlightShadowControl,
	CTeam,
	CTeamplayRoundBasedRulesProxy,
	CTEArmorRicochet,
	CTEBaseBeam,
	CTEBeamEntPoint,
	CTEBeamEnts,
	CTEBeamFollow,
	CTEBeamLaser,
	CTEBeamPoints,
	CTEBeamRing,
	CTEBeamRingPoint,
	CTEBeamSpline,
	CTEBloodSprite,
	CTEBloodStream,
	CTEBreakModel,
	CTEBSPDecal,
	CTEBubbles,
	CTEBubbleTrail,
	CTEClientProjectile,
	CTEDecal,
	CTEDust,
	CTEDynamicLight,
	CTEEffectDispatch,
	CTEEnergySplash,
	CTEExplosion,
	CTEFireBullets,
	CTEFizz,
	CTEFootprintDecal,
	CTEFoundryHelpers,
	CTEGaussExplosion,
	CTEGlowSprite,
	CTEImpact,
	CTEKillPlayerAttachments,
	CTELargeFunnel,
	CTEMetalSparks,
	CTEMuzzleFlash,
	CTEParticleSystem,
	CTEPhysicsProp,
	CTEPlantBomb,
	CTEPlayerAnimEvent,
	CTEPlayerDecal,
	CTEProjectedDecal,
	CTERadioIcon,
	CTEShatterSurface,
	CTEShowLine,
	CTesla,
	CTESmoke,
	CTESparks,
	CTESprite,
	CTESpriteSpray,
	CTest_ProxyToggle_Networkable,
	CTestTraceline,
	CTEWorldDecal,
	CTriggerPlayerMovement,
	CTriggerSoundOperator,
	CVGuiScreen,
	CVoteController,
	CWaterBullet,
	CWaterLODControl,
	CWeaponAug,
	CWeaponAWP,
	CWeaponBaseItem,
	CWeaponBizon,
	CWeaponCSBase,
	CWeaponCSBaseGun,
	CWeaponCycler,
	CWeaponElite,
	CWeaponFamas,
	CWeaponFiveSeven,
	CWeaponG3SG1,
	CWeaponGalil,
	CWeaponGalilAR,
	CWeaponGlock,
	CWeaponHKP2000,
	CWeaponM249,
	CWeaponM3,
	CWeaponM4A1,
	CWeaponMAC10,
	CWeaponMag7,
	CWeaponMP5Navy,
	CWeaponMP7,
	CWeaponMP9,
	CWeaponNegev,
	CWeaponNOVA,
	CWeaponP228,
	CWeaponP250,
	CWeaponP90,
	CWeaponSawedoff,
	CWeaponSCAR20,
	CWeaponScout,
	CWeaponSG550,
	CWeaponSG552,
	CWeaponSG556,
	CWeaponSSG08,
	CWeaponTaser,
	CWeaponTec9,
	CWeaponTMP,
	CWeaponUMP45,
	CWeaponUSP,
	CWeaponXM1014,
	CWorld,
	CWorldVguiText,
	DustTrail,
	MovieExplosion,
	ParticleSmokeGrenade,
	RocketTrail,
	SmokeTrail,
	SporeExplosion,
	SporeTrail,
};

enum Hitboxes_t : int {
	HITBOX_HEAD = 0,
	HITBOX_NECK,
	HITBOX_LOWER_NECK,
	HITBOX_PELVIS,
	HITBOX_BODY,
	HITBOX_THORAX,
	HITBOX_CHEST,
	HITBOX_UPPER_CHEST,
	HITBOX_R_THIGH,
	HITBOX_L_THIGH,
	HITBOX_R_CALF,
	HITBOX_L_CALF,
	HITBOX_R_FOOT,
	HITBOX_L_FOOT,
	HITBOX_R_HAND,
	HITBOX_L_HAND,
	HITBOX_R_UPPER_ARM,
	HITBOX_R_FOREARM,
	HITBOX_L_UPPER_ARM,
	HITBOX_L_FOREARM,
	HITBOX_MAX
};

enum RenderFlags_t : uint32_t {
	STUDIO_NONE = 0x00000000,
	STUDIO_RENDER = 0x00000001,
	STUDIO_VIEWXFORMATTACHMENTS = 0x00000002,
	STUDIO_DRAWTRANSLUCENTSUBMODELS = 0x00000004,
	STUDIO_TWOPASS = 0x00000008,
	STUDIO_STATIC_LIGHTING = 0x00000010,
	STUDIO_WIREFRAME = 0x00000020,
	STUDIO_ITEM_BLINK = 0x00000040,
	STUDIO_NOSHADOWS = 0x00000080,
	STUDIO_WIREFRAME_VCOLLIDE = 0x00000100,
	STUDIO_NOLIGHTING_OR_CUBEMAP = 0x00000200,
	STUDIO_SKIP_FLEXES = 0x00000400,
	STUDIO_DONOTMODIFYSTENCILSTATE = 0x00000800,
	STUDIO_TRANSPARENCY = 0x80000000,
	STUDIO_SHADOWDEPTHTEXTURE = 0x40000000,
	STUDIO_SHADOWTEXTURE = 0x20000000,
	STUDIO_SKIP_DECALS = 0x10000000
};

enum BoneFlags_t : int {
	BONE_USED_BY_ANYTHING = 0x000FFF00,
	BONE_USED_BY_HITBOX = 0x00000100, // bone (or child) is used by a hit box
	BONE_USED_BY_ATTACHMENT = 0x00000200, // bone (or child) is used by an attachment point
	BONE_USED_BY_VERTEX_MASK = 0x0003FC00,
	BONE_USED_BY_VERTEX_LOD0 = 0x00000400, // bone (or child) is used by the toplevel model via skinned vertex
	BONE_USED_BY_VERTEX_LOD1 = 0x00000800,
	BONE_USED_BY_VERTEX_LOD2 = 0x00001000,
	BONE_USED_BY_VERTEX_LOD3 = 0x00002000,
	BONE_USED_BY_VERTEX_LOD4 = 0x00004000,
	BONE_USED_BY_VERTEX_LOD5 = 0x00008000,
	BONE_USED_BY_VERTEX_LOD6 = 0x00010000,
	BONE_USED_BY_VERTEX_LOD7 = 0x00020000,
	BONE_USED_BY_BONE_MERGE = 0x00040000
};

enum CSWeaponType : int {
	WEAPONTYPE_UNKNOWN = -1,
	WEAPONTYPE_KNIFE,
	WEAPONTYPE_PISTOL,
	WEAPONTYPE_SUBMACHINEGUN,
	WEAPONTYPE_RIFLE,
	WEAPONTYPE_SHOTGUN,
	WEAPONTYPE_SNIPER_RIFLE,
	WEAPONTYPE_MACHINEGUN,
	WEAPONTYPE_C4,
	WEAPONTYPE_TASER,
	WEAPONTYPE_GRENADE,
	WEAPONTYPE_HEALTHSHOT = 11
};

enum teams_t : int {
	TEAM_NOTEAM = 0,
	TEAM_SPECTATOR,
	TEAM_TERRORISTS,
	TEAM_COUNTERTERRORISTS
};

enum effects_t : int {
	EF_BONEMERGE = 0x001,	// Performs bone merge on client side
	EF_BRIGHTLIGHT = 0x002,	// DLIGHT centered at entity origin
	EF_DIMLIGHT = 0x004,	// player flashlight
	EF_NOINTERP = 0x008,	// don't interpolate the next frame
	EF_NOSHADOW = 0x010,	// Don't cast no shadow
	EF_NODRAW = 0x020,	// don't draw entity
	EF_NORECEIVESHADOW = 0x040,	// Don't receive no shadow
	EF_BONEMERGE_FASTCULL = 0x080,	// For use with EF_BONEMERGE. If this is set, then it places this ent's origin at its
	EF_ITEM_BLINK = 0x100,	// blink an item so that the user notices it.
	EF_PARENT_ANIMATES = 0x200,	// always assume that the parent entity is animating
	EF_MAX_BITS = 10
};

enum InvalidatePhysicsBits_t : int {
	POSITION_CHANGED = 0x1,
	ANGLES_CHANGED = 0x2,
	VELOCITY_CHANGED = 0x4,
	ANIMATION_CHANGED = 0x8,
};

enum DataUpdateType_t : int {
	DATA_UPDATE_CREATED = 0,
	DATA_UPDATE_DATATABLE_CHANGED,
};

enum LifeStates_t : int {
	LIFE_ALIVE = 0,
	LIFE_DYING,
	LIFE_DEAD,
	LIFE_RESPAWNABLE,
	LIFE_DISCARDBODY,
};

enum activity : int {
	ACT_RESET,
	ACT_IDLE,
	ACT_TRANSITION,
	ACT_COVER,
	ACT_COVER_MED,
	ACT_COVER_LOW,
	ACT_WALK,
	ACT_WALK_AIM,
	ACT_WALK_CROUCH,
	ACT_WALK_CROUCH_AIM,
	ACT_RUN,
	ACT_RUN_AIM,
	ACT_RUN_CROUCH,
	ACT_RUN_CROUCH_AIM,
	ACT_RUN_PROTECTED,
	ACT_SCRIPT_CUSTOM_MOVE,
	ACT_RANGE_ATTACK1,
	ACT_RANGE_ATTACK2,
	ACT_RANGE_ATTACK1_LOW,
	ACT_RANGE_ATTACK2_LOW,
	ACT_DIESIMPLE,
	ACT_DIEBACKWARD,
	ACT_DIEFORWARD,
	ACT_DIEVIOLENT,
	ACT_DIERAGDOLL,
	ACT_FLY,
	ACT_HOVER,
	ACT_GLIDE,
	ACT_SWIM,
	ACT_JUMP,
	ACT_HOP,
	ACT_LEAP,
	ACT_LAND,
	ACT_CLIMB_UP,
	ACT_CLIMB_DOWN,
	ACT_CLIMB_DISMOUNT,
	ACT_SHIPLADDER_UP,
	ACT_SHIPLADDER_DOWN,
	ACT_STRAFE_LEFT,
	ACT_STRAFE_RIGHT,
	ACT_ROLL_LEFT,
	ACT_ROLL_RIGHT,
	ACT_TURN_LEFT,
	ACT_TURN_RIGHT,
	ACT_CROUCH,
	ACT_CROUCHIDLE,
	ACT_STAND,
	ACT_USE,
	ACT_ALIEN_BURROW_IDLE,
	ACT_ALIEN_BURROW_OUT,
	ACT_SIGNAL1,
	ACT_SIGNAL2,
	ACT_SIGNAL3,
	ACT_SIGNAL_ADVANCE,
	ACT_SIGNAL_FORWARD,
	ACT_SIGNAL_GROUP,
	ACT_SIGNAL_HALT,
	ACT_SIGNAL_LEFT,
	ACT_SIGNAL_RIGHT,
	ACT_SIGNAL_TAKECOVER,
	ACT_LOOKBACK_RIGHT,
	ACT_LOOKBACK_LEFT,
	ACT_COWER,
	ACT_SMALL_FLINCH,
	ACT_BIG_FLINCH,
	ACT_MELEE_ATTACK1,
	ACT_MELEE_ATTACK2,
	ACT_RELOAD,
	ACT_RELOAD_START,
	ACT_RELOAD_FINISH,
	ACT_RELOAD_LOW,
	ACT_ARM,
	ACT_DISARM,
	ACT_DROP_WEAPON,
	ACT_DROP_WEAPON_SHOTGUN,
	ACT_PICKUP_GROUND,
	ACT_PICKUP_RACK,
	ACT_IDLE_ANGRY,
	ACT_IDLE_RELAXED,
	ACT_IDLE_STIMULATED,
	ACT_IDLE_AGITATED,
	ACT_IDLE_STEALTH,
	ACT_IDLE_HURT,
	ACT_WALK_RELAXED,
	ACT_WALK_STIMULATED,
	ACT_WALK_AGITATED,
	ACT_WALK_STEALTH,
	ACT_RUN_RELAXED,
	ACT_RUN_STIMULATED,
	ACT_RUN_AGITATED,
	ACT_RUN_STEALTH,
	ACT_IDLE_AIM_RELAXED,
	ACT_IDLE_AIM_STIMULATED,
	ACT_IDLE_AIM_AGITATED,
	ACT_IDLE_AIM_STEALTH,
	ACT_WALK_AIM_RELAXED,
	ACT_WALK_AIM_STIMULATED,
	ACT_WALK_AIM_AGITATED,
	ACT_WALK_AIM_STEALTH,
	ACT_RUN_AIM_RELAXED,
	ACT_RUN_AIM_STIMULATED,
	ACT_RUN_AIM_AGITATED,
	ACT_RUN_AIM_STEALTH,
	ACT_CROUCHIDLE_STIMULATED,
	ACT_CROUCHIDLE_AIM_STIMULATED,
	ACT_CROUCHIDLE_AGITATED,
	ACT_WALK_HURT,
	ACT_RUN_HURT,
	ACT_SPECIAL_ATTACK1,
	ACT_SPECIAL_ATTACK2,
	ACT_COMBAT_IDLE,
	ACT_WALK_SCARED,
	ACT_RUN_SCARED,
	ACT_VICTORY_DANCE,
	ACT_DIE_HEADSHOT,
	ACT_DIE_CHESTSHOT,
	ACT_DIE_GUTSHOT,
	ACT_DIE_BACKSHOT,
	ACT_FLINCH_HEAD,
	ACT_FLINCH_CHEST,
	ACT_FLINCH_STOMACH,
	ACT_FLINCH_LEFTARM,
	ACT_FLINCH_RIGHTARM,
	ACT_FLINCH_LEFTLEG,
	ACT_FLINCH_RIGHTLEG,
	ACT_FLINCH_PHYSICS,
	ACT_FLINCH_HEAD_BACK,
	ACT_FLINCH_HEAD_LEFT,
	ACT_FLINCH_HEAD_RIGHT,
	ACT_FLINCH_CHEST_BACK,
	ACT_FLINCH_STOMACH_BACK,
	ACT_FLINCH_CROUCH_FRONT,
	ACT_FLINCH_CROUCH_BACK,
	ACT_FLINCH_CROUCH_LEFT,
	ACT_FLINCH_CROUCH_RIGHT,
	ACT_IDLE_ON_FIRE,
	ACT_WALK_ON_FIRE,
	ACT_RUN_ON_FIRE,
	ACT_RAPPEL_LOOP,
	ACT_180_LEFT,
	ACT_180_RIGHT,
	ACT_90_LEFT,
	ACT_90_RIGHT,
	ACT_STEP_LEFT,
	ACT_STEP_RIGHT,
	ACT_STEP_BACK,
	ACT_STEP_FORE,
	ACT_GESTURE_RANGE_ATTACK1,
	ACT_GESTURE_RANGE_ATTACK2,
	ACT_GESTURE_MELEE_ATTACK1,
	ACT_GESTURE_MELEE_ATTACK2,
	ACT_GESTURE_RANGE_ATTACK1_LOW,
	ACT_GESTURE_RANGE_ATTACK2_LOW,
	ACT_MELEE_ATTACK_SWING_GESTURE,
	ACT_GESTURE_SMALL_FLINCH,
	ACT_GESTURE_BIG_FLINCH,
	ACT_GESTURE_FLINCH_BLAST,
	ACT_GESTURE_FLINCH_BLAST_SHOTGUN,
	ACT_GESTURE_FLINCH_BLAST_DAMAGED,
	ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN,
	ACT_GESTURE_FLINCH_HEAD,
	ACT_GESTURE_FLINCH_CHEST,
	ACT_GESTURE_FLINCH_STOMACH,
	ACT_GESTURE_FLINCH_LEFTARM,
	ACT_GESTURE_FLINCH_RIGHTARM,
	ACT_GESTURE_FLINCH_LEFTLEG,
	ACT_GESTURE_FLINCH_RIGHTLEG,
	ACT_GESTURE_TURN_LEFT,
	ACT_GESTURE_TURN_RIGHT,
	ACT_GESTURE_TURN_LEFT45,
	ACT_GESTURE_TURN_RIGHT45,
	ACT_GESTURE_TURN_LEFT90,
	ACT_GESTURE_TURN_RIGHT90,
	ACT_GESTURE_TURN_LEFT45_FLAT,
	ACT_GESTURE_TURN_RIGHT45_FLAT,
	ACT_GESTURE_TURN_LEFT90_FLAT,
	ACT_GESTURE_TURN_RIGHT90_FLAT,
	ACT_BARNACLE_HIT,
	ACT_BARNACLE_PULL,
	ACT_BARNACLE_CHOMP,
	ACT_BARNACLE_CHEW,
	ACT_DO_NOT_DISTURB,
	ACT_SPECIFIC_SEQUENCE,
	ACT_VM_DRAW,
	ACT_VM_HOLSTER,
	ACT_VM_IDLE,
	ACT_VM_FIDGET,
	ACT_VM_PULLBACK,
	ACT_VM_PULLBACK_HIGH,
	ACT_VM_PULLBACK_LOW,
	ACT_VM_THROW,
	ACT_VM_PULLPIN,
	ACT_VM_PRIMARYATTACK,
	ACT_VM_SECONDARYATTACK,
	ACT_VM_RELOAD,
	ACT_VM_DRYFIRE,
	ACT_VM_HITLEFT,
	ACT_VM_HITLEFT2,
	ACT_VM_HITRIGHT,
	ACT_VM_HITRIGHT2,
	ACT_VM_HITCENTER,
	ACT_VM_HITCENTER2,
	ACT_VM_MISSLEFT,
	ACT_VM_MISSLEFT2,
	ACT_VM_MISSRIGHT,
	ACT_VM_MISSRIGHT2,
	ACT_VM_MISSCENTER,
	ACT_VM_MISSCENTER2,
	ACT_VM_HAULBACK,
	ACT_VM_SWINGHARD,
	ACT_VM_SWINGMISS,
	ACT_VM_SWINGHIT,
	ACT_VM_IDLE_TO_LOWERED,
	ACT_VM_IDLE_LOWERED,
	ACT_VM_LOWERED_TO_IDLE,
	ACT_VM_RECOIL1,
	ACT_VM_RECOIL2,
	ACT_VM_RECOIL3,
	ACT_VM_PICKUP,
	ACT_VM_RELEASE,
	ACT_VM_ATTACH_SILENCER,
	ACT_VM_DETACH_SILENCER,
	ACT_VM_EMPTY_FIRE,
	ACT_VM_EMPTY_RELOAD,
	ACT_VM_EMPTY_DRAW,
	ACT_VM_EMPTY_IDLE,
	ACT_SLAM_STICKWALL_IDLE,
	ACT_SLAM_STICKWALL_ND_IDLE,
	ACT_SLAM_STICKWALL_ATTACH,
	ACT_SLAM_STICKWALL_ATTACH2,
	ACT_SLAM_STICKWALL_ND_ATTACH,
	ACT_SLAM_STICKWALL_ND_ATTACH2,
	ACT_SLAM_STICKWALL_DETONATE,
	ACT_SLAM_STICKWALL_DETONATOR_HOLSTER,
	ACT_SLAM_STICKWALL_DRAW,
	ACT_SLAM_STICKWALL_ND_DRAW,
	ACT_SLAM_STICKWALL_TO_THROW,
	ACT_SLAM_STICKWALL_TO_THROW_ND,
	ACT_SLAM_STICKWALL_TO_TRIPMINE_ND,
	ACT_SLAM_THROW_IDLE,
	ACT_SLAM_THROW_ND_IDLE,
	ACT_SLAM_THROW_THROW,
	ACT_SLAM_THROW_THROW2,
	ACT_SLAM_THROW_THROW_ND,
	ACT_SLAM_THROW_THROW_ND2,
	ACT_SLAM_THROW_DRAW,
	ACT_SLAM_THROW_ND_DRAW,
	ACT_SLAM_THROW_TO_STICKWALL,
	ACT_SLAM_THROW_TO_STICKWALL_ND,
	ACT_SLAM_THROW_DETONATE,
	ACT_SLAM_THROW_DETONATOR_HOLSTER,
	ACT_SLAM_THROW_TO_TRIPMINE_ND,
	ACT_SLAM_TRIPMINE_IDLE,
	ACT_SLAM_TRIPMINE_DRAW,
	ACT_SLAM_TRIPMINE_ATTACH,
	ACT_SLAM_TRIPMINE_ATTACH2,
	ACT_SLAM_TRIPMINE_TO_STICKWALL_ND,
	ACT_SLAM_TRIPMINE_TO_THROW_ND,
	ACT_SLAM_DETONATOR_IDLE,
	ACT_SLAM_DETONATOR_DRAW,
	ACT_SLAM_DETONATOR_DETONATE,
	ACT_SLAM_DETONATOR_HOLSTER,
	ACT_SLAM_DETONATOR_STICKWALL_DRAW,
	ACT_SLAM_DETONATOR_THROW_DRAW,
	ACT_SHOTGUN_RELOAD_START,
	ACT_SHOTGUN_RELOAD_FINISH,
	ACT_SHOTGUN_PUMP,
	ACT_SMG2_IDLE2,
	ACT_SMG2_FIRE2,
	ACT_SMG2_DRAW2,
	ACT_SMG2_RELOAD2,
	ACT_SMG2_DRYFIRE2,
	ACT_SMG2_TOAUTO,
	ACT_SMG2_TOBURST,
	ACT_PHYSCANNON_UPGRADE,
	ACT_RANGE_ATTACK_AR1,
	ACT_RANGE_ATTACK_AR2,
	ACT_RANGE_ATTACK_AR2_LOW,
	ACT_RANGE_ATTACK_AR2_GRENADE,
	ACT_RANGE_ATTACK_HMG1,
	ACT_RANGE_ATTACK_ML,
	ACT_RANGE_ATTACK_SMG1,
	ACT_RANGE_ATTACK_SMG1_LOW,
	ACT_RANGE_ATTACK_SMG2,
	ACT_RANGE_ATTACK_SHOTGUN,
	ACT_RANGE_ATTACK_SHOTGUN_LOW,
	ACT_RANGE_ATTACK_PISTOL,
	ACT_RANGE_ATTACK_PISTOL_LOW,
	ACT_RANGE_ATTACK_SLAM,
	ACT_RANGE_ATTACK_TRIPWIRE,
	ACT_RANGE_ATTACK_THROW,
	ACT_RANGE_ATTACK_SNIPER_RIFLE,
	ACT_RANGE_ATTACK_RPG,
	ACT_MELEE_ATTACK_SWING,
	ACT_RANGE_AIM_LOW,
	ACT_RANGE_AIM_SMG1_LOW,
	ACT_RANGE_AIM_PISTOL_LOW,
	ACT_RANGE_AIM_AR2_LOW,
	ACT_COVER_PISTOL_LOW,
	ACT_COVER_SMG1_LOW,
	ACT_GESTURE_RANGE_ATTACK_AR1,
	ACT_GESTURE_RANGE_ATTACK_AR2,
	ACT_GESTURE_RANGE_ATTACK_AR2_GRENADE,
	ACT_GESTURE_RANGE_ATTACK_HMG1,
	ACT_GESTURE_RANGE_ATTACK_ML,
	ACT_GESTURE_RANGE_ATTACK_SMG1,
	ACT_GESTURE_RANGE_ATTACK_SMG1_LOW,
	ACT_GESTURE_RANGE_ATTACK_SMG2,
	ACT_GESTURE_RANGE_ATTACK_SHOTGUN,
	ACT_GESTURE_RANGE_ATTACK_PISTOL,
	ACT_GESTURE_RANGE_ATTACK_PISTOL_LOW,
	ACT_GESTURE_RANGE_ATTACK_SLAM,
	ACT_GESTURE_RANGE_ATTACK_TRIPWIRE,
	ACT_GESTURE_RANGE_ATTACK_THROW,
	ACT_GESTURE_RANGE_ATTACK_SNIPER_RIFLE,
	ACT_GESTURE_MELEE_ATTACK_SWING,
	ACT_IDLE_RIFLE,
	ACT_IDLE_SMG1,
	ACT_IDLE_ANGRY_SMG1,
	ACT_IDLE_PISTOL,
	ACT_IDLE_ANGRY_PISTOL,
	ACT_IDLE_ANGRY_SHOTGUN,
	ACT_IDLE_STEALTH_PISTOL,
	ACT_IDLE_PACKAGE,
	ACT_WALK_PACKAGE,
	ACT_IDLE_SUITCASE,
	ACT_WALK_SUITCASE,
	ACT_IDLE_SMG1_RELAXED,
	ACT_IDLE_SMG1_STIMULATED,
	ACT_WALK_RIFLE_RELAXED,
	ACT_RUN_RIFLE_RELAXED,
	ACT_WALK_RIFLE_STIMULATED,
	ACT_RUN_RIFLE_STIMULATED,
	ACT_IDLE_AIM_RIFLE_STIMULATED,
	ACT_WALK_AIM_RIFLE_STIMULATED,
	ACT_RUN_AIM_RIFLE_STIMULATED,
	ACT_IDLE_SHOTGUN_RELAXED,
	ACT_IDLE_SHOTGUN_STIMULATED,
	ACT_IDLE_SHOTGUN_AGITATED,
	ACT_WALK_ANGRY,
	ACT_POLICE_HARASS1,
	ACT_POLICE_HARASS2,
	ACT_IDLE_MANNEDGUN,
	ACT_IDLE_MELEE,
	ACT_IDLE_ANGRY_MELEE,
	ACT_IDLE_RPG_RELAXED,
	ACT_IDLE_RPG,
	ACT_IDLE_ANGRY_RPG,
	ACT_COVER_LOW_RPG,
	ACT_WALK_RPG,
	ACT_RUN_RPG,
	ACT_WALK_CROUCH_RPG,
	ACT_RUN_CROUCH_RPG,
	ACT_WALK_RPG_RELAXED,
	ACT_RUN_RPG_RELAXED,
	ACT_WALK_RIFLE,
	ACT_WALK_AIM_RIFLE,
	ACT_WALK_CROUCH_RIFLE,
	ACT_WALK_CROUCH_AIM_RIFLE,
	ACT_RUN_RIFLE,
	ACT_RUN_AIM_RIFLE,
	ACT_RUN_CROUCH_RIFLE,
	ACT_RUN_CROUCH_AIM_RIFLE,
	ACT_RUN_STEALTH_PISTOL,
	ACT_WALK_AIM_SHOTGUN,
	ACT_RUN_AIM_SHOTGUN,
	ACT_WALK_PISTOL,
	ACT_RUN_PISTOL,
	ACT_WALK_AIM_PISTOL,
	ACT_RUN_AIM_PISTOL,
	ACT_WALK_STEALTH_PISTOL,
	ACT_WALK_AIM_STEALTH_PISTOL,
	ACT_RUN_AIM_STEALTH_PISTOL,
	ACT_RELOAD_PISTOL,
	ACT_RELOAD_PISTOL_LOW,
	ACT_RELOAD_SMG1,
	ACT_RELOAD_SMG1_LOW,
	ACT_RELOAD_SHOTGUN,
	ACT_RELOAD_SHOTGUN_LOW,
	ACT_GESTURE_RELOAD,
	ACT_GESTURE_RELOAD_PISTOL,
	ACT_GESTURE_RELOAD_SMG1,
	ACT_GESTURE_RELOAD_SHOTGUN,
	ACT_BUSY_LEAN_LEFT,
	ACT_BUSY_LEAN_LEFT_ENTRY,
	ACT_BUSY_LEAN_LEFT_EXIT,
	ACT_BUSY_LEAN_BACK,
	ACT_BUSY_LEAN_BACK_ENTRY,
	ACT_BUSY_LEAN_BACK_EXIT,
	ACT_BUSY_SIT_GROUND,
	ACT_BUSY_SIT_GROUND_ENTRY,
	ACT_BUSY_SIT_GROUND_EXIT,
	ACT_BUSY_SIT_CHAIR,
	ACT_BUSY_SIT_CHAIR_ENTRY,
	ACT_BUSY_SIT_CHAIR_EXIT,
	ACT_BUSY_STAND,
	ACT_BUSY_QUEUE,
	ACT_DUCK_DODGE,
	ACT_DIE_BARNACLE_SWALLOW,
	ACT_GESTURE_BARNACLE_STRANGLE,
	ACT_PHYSCANNON_DETACH,
	ACT_PHYSCANNON_ANIMATE,
	ACT_PHYSCANNON_ANIMATE_PRE,
	ACT_PHYSCANNON_ANIMATE_POST,
	ACT_DIE_FRONTSIDE,
	ACT_DIE_RIGHTSIDE,
	ACT_DIE_BACKSIDE,
	ACT_DIE_LEFTSIDE,
	ACT_DIE_CROUCH_FRONTSIDE,
	ACT_DIE_CROUCH_RIGHTSIDE,
	ACT_DIE_CROUCH_BACKSIDE,
	ACT_DIE_CROUCH_LEFTSIDE,
	ACT_OPEN_DOOR,
	ACT_DI_ALYX_ZOMBIE_MELEE,
	ACT_DI_ALYX_ZOMBIE_TORSO_MELEE,
	ACT_DI_ALYX_HEADCRAB_MELEE,
	ACT_DI_ALYX_ANTLION,
	ACT_DI_ALYX_ZOMBIE_SHOTGUN64,
	ACT_DI_ALYX_ZOMBIE_SHOTGUN26,
	ACT_READINESS_RELAXED_TO_STIMULATED,
	ACT_READINESS_RELAXED_TO_STIMULATED_WALK,
	ACT_READINESS_AGITATED_TO_STIMULATED,
	ACT_READINESS_STIMULATED_TO_RELAXED,
	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED,
	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED_WALK,
	ACT_READINESS_PISTOL_AGITATED_TO_STIMULATED,
	ACT_READINESS_PISTOL_STIMULATED_TO_RELAXED,
	ACT_IDLE_CARRY,
	ACT_WALK_CARRY,
	ACT_STARTDYING,
	ACT_DYINGLOOP,
	ACT_DYINGTODEAD,
	ACT_RIDE_MANNED_GUN,
	ACT_VM_SPRINT_ENTER,
	ACT_VM_SPRINT_IDLE,
	ACT_VM_SPRINT_LEAVE,
	ACT_FIRE_START,
	ACT_FIRE_LOOP,
	ACT_FIRE_END,
	ACT_CROUCHING_GRENADEIDLE,
	ACT_CROUCHING_GRENADEREADY,
	ACT_CROUCHING_PRIMARYATTACK,
	ACT_OVERLAY_GRENADEIDLE,
	ACT_OVERLAY_GRENADEREADY,
	ACT_OVERLAY_PRIMARYATTACK,
	ACT_OVERLAY_SHIELD_UP,
	ACT_OVERLAY_SHIELD_DOWN,
	ACT_OVERLAY_SHIELD_UP_IDLE,
	ACT_OVERLAY_SHIELD_ATTACK,
	ACT_OVERLAY_SHIELD_KNOCKBACK,
	ACT_SHIELD_UP,
	ACT_SHIELD_DOWN,
	ACT_SHIELD_UP_IDLE,
	ACT_SHIELD_ATTACK,
	ACT_SHIELD_KNOCKBACK,
	ACT_CROUCHING_SHIELD_UP,
	ACT_CROUCHING_SHIELD_DOWN,
	ACT_CROUCHING_SHIELD_UP_IDLE,
	ACT_CROUCHING_SHIELD_ATTACK,
	ACT_CROUCHING_SHIELD_KNOCKBACK,
	ACT_TURNRIGHT45,
	ACT_TURNLEFT45,
	ACT_TURN,
	ACT_OBJ_ASSEMBLING,
	ACT_OBJ_DISMANTLING,
	ACT_OBJ_STARTUP,
	ACT_OBJ_RUNNING,
	ACT_OBJ_IDLE,
	ACT_OBJ_PLACING,
	ACT_OBJ_DETERIORATING,
	ACT_OBJ_UPGRADING,
	ACT_DEPLOY,
	ACT_DEPLOY_IDLE,
	ACT_UNDEPLOY,
	ACT_CROSSBOW_DRAW_UNLOADED,
	ACT_GAUSS_SPINUP,
	ACT_GAUSS_SPINCYCLE,
	ACT_VM_PRIMARYATTACK_SILENCED,
	ACT_VM_RELOAD_SILENCED,
	ACT_VM_DRYFIRE_SILENCED,
	ACT_VM_IDLE_SILENCED,
	ACT_VM_DRAW_SILENCED,
	ACT_VM_IDLE_EMPTY_LEFT,
	ACT_VM_DRYFIRE_LEFT,
	ACT_VM_IS_DRAW,
	ACT_VM_IS_HOLSTER,
	ACT_VM_IS_IDLE,
	ACT_VM_IS_PRIMARYATTACK,
	ACT_PLAYER_IDLE_FIRE,
	ACT_PLAYER_CROUCH_FIRE,
	ACT_PLAYER_CROUCH_WALK_FIRE,
	ACT_PLAYER_WALK_FIRE,
	ACT_PLAYER_RUN_FIRE,
	ACT_IDLETORUN,
	ACT_RUNTOIDLE,
	ACT_VM_DRAW_DEPLOYED,
	ACT_HL2MP_IDLE_MELEE,
	ACT_HL2MP_RUN_MELEE,
	ACT_HL2MP_IDLE_CROUCH_MELEE,
	ACT_HL2MP_WALK_CROUCH_MELEE,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,
	ACT_HL2MP_GESTURE_RELOAD_MELEE,
	ACT_HL2MP_JUMP_MELEE,
	ACT_VM_FIZZLE,
	ACT_MP_STAND_IDLE,
	ACT_MP_CROUCH_IDLE,
	ACT_MP_CROUCH_DEPLOYED_IDLE,
	ACT_MP_CROUCH_DEPLOYED,
	ACT_MP_DEPLOYED_IDLE,
	ACT_MP_RUN,
	ACT_MP_WALK,
	ACT_MP_AIRWALK,
	ACT_MP_CROUCHWALK,
	ACT_MP_SPRINT,
	ACT_MP_JUMP,
	ACT_MP_JUMP_START,
	ACT_MP_JUMP_FLOAT,
	ACT_MP_JUMP_LAND,
	ACT_MP_JUMP_IMPACT_N,
	ACT_MP_JUMP_IMPACT_E,
	ACT_MP_JUMP_IMPACT_W,
	ACT_MP_JUMP_IMPACT_S,
	ACT_MP_JUMP_IMPACT_TOP,
	ACT_MP_DOUBLEJUMP,
	ACT_MP_SWIM,
	ACT_MP_DEPLOYED,
	ACT_MP_SWIM_DEPLOYED,
	ACT_MP_VCD,
	ACT_MP_ATTACK_STAND_PRIMARYFIRE,
	ACT_MP_ATTACK_STAND_PRIMARYFIRE_DEPLOYED,
	ACT_MP_ATTACK_STAND_SECONDARYFIRE,
	ACT_MP_ATTACK_STAND_GRENADE,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE_DEPLOYED,
	ACT_MP_ATTACK_CROUCH_SECONDARYFIRE,
	ACT_MP_ATTACK_CROUCH_GRENADE,
	ACT_MP_ATTACK_SWIM_PRIMARYFIRE,
	ACT_MP_ATTACK_SWIM_SECONDARYFIRE,
	ACT_MP_ATTACK_SWIM_GRENADE,
	ACT_MP_ATTACK_AIRWALK_PRIMARYFIRE,
	ACT_MP_ATTACK_AIRWALK_SECONDARYFIRE,
	ACT_MP_ATTACK_AIRWALK_GRENADE,
	ACT_MP_RELOAD_STAND,
	ACT_MP_RELOAD_STAND_LOOP,
	ACT_MP_RELOAD_STAND_END,
	ACT_MP_RELOAD_CROUCH,
	ACT_MP_RELOAD_CROUCH_LOOP,
	ACT_MP_RELOAD_CROUCH_END,
	ACT_MP_RELOAD_SWIM,
	ACT_MP_RELOAD_SWIM_LOOP,
	ACT_MP_RELOAD_SWIM_END,
	ACT_MP_RELOAD_AIRWALK,
	ACT_MP_RELOAD_AIRWALK_LOOP,
	ACT_MP_RELOAD_AIRWALK_END,
	ACT_MP_ATTACK_STAND_PREFIRE,
	ACT_MP_ATTACK_STAND_POSTFIRE,
	ACT_MP_ATTACK_STAND_STARTFIRE,
	ACT_MP_ATTACK_CROUCH_PREFIRE,
	ACT_MP_ATTACK_CROUCH_POSTFIRE,
	ACT_MP_ATTACK_SWIM_PREFIRE,
	ACT_MP_ATTACK_SWIM_POSTFIRE,
	ACT_MP_STAND_PRIMARY,
	ACT_MP_CROUCH_PRIMARY,
	ACT_MP_RUN_PRIMARY,
	ACT_MP_WALK_PRIMARY,
	ACT_MP_AIRWALK_PRIMARY,
	ACT_MP_CROUCHWALK_PRIMARY,
	ACT_MP_JUMP_PRIMARY,
	ACT_MP_JUMP_START_PRIMARY,
	ACT_MP_JUMP_FLOAT_PRIMARY,
	ACT_MP_JUMP_LAND_PRIMARY,
	ACT_MP_SWIM_PRIMARY,
	ACT_MP_DEPLOYED_PRIMARY,
	ACT_MP_SWIM_DEPLOYED_PRIMARY,
	ACT_MP_ATTACK_STAND_PRIMARY,
	ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED,
	ACT_MP_ATTACK_CROUCH_PRIMARY,
	ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED,
	ACT_MP_ATTACK_SWIM_PRIMARY,
	ACT_MP_ATTACK_AIRWALK_PRIMARY,
	ACT_MP_RELOAD_STAND_PRIMARY,
	ACT_MP_RELOAD_STAND_PRIMARY_LOOP,
	ACT_MP_RELOAD_STAND_PRIMARY_END,
	ACT_MP_RELOAD_CROUCH_PRIMARY,
	ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP,
	ACT_MP_RELOAD_CROUCH_PRIMARY_END,
	ACT_MP_RELOAD_SWIM_PRIMARY,
	ACT_MP_RELOAD_SWIM_PRIMARY_LOOP,
	ACT_MP_RELOAD_SWIM_PRIMARY_END,
	ACT_MP_RELOAD_AIRWALK_PRIMARY,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_END,
	ACT_MP_ATTACK_STAND_GRENADE_PRIMARY,
	ACT_MP_ATTACK_CROUCH_GRENADE_PRIMARY,
	ACT_MP_ATTACK_SWIM_GRENADE_PRIMARY,
	ACT_MP_ATTACK_AIRWALK_GRENADE_PRIMARY,
	ACT_MP_STAND_SECONDARY,
	ACT_MP_CROUCH_SECONDARY,
	ACT_MP_RUN_SECONDARY,
	ACT_MP_WALK_SECONDARY,
	ACT_MP_AIRWALK_SECONDARY,
	ACT_MP_CROUCHWALK_SECONDARY,
	ACT_MP_JUMP_SECONDARY,
	ACT_MP_JUMP_START_SECONDARY,
	ACT_MP_JUMP_FLOAT_SECONDARY,
	ACT_MP_JUMP_LAND_SECONDARY,
	ACT_MP_SWIM_SECONDARY,
	ACT_MP_ATTACK_STAND_SECONDARY,
	ACT_MP_ATTACK_CROUCH_SECONDARY,
	ACT_MP_ATTACK_SWIM_SECONDARY,
	ACT_MP_ATTACK_AIRWALK_SECONDARY,
	ACT_MP_RELOAD_STAND_SECONDARY,
	ACT_MP_RELOAD_STAND_SECONDARY_LOOP,
	ACT_MP_RELOAD_STAND_SECONDARY_END,
	ACT_MP_RELOAD_CROUCH_SECONDARY,
	ACT_MP_RELOAD_CROUCH_SECONDARY_LOOP,
	ACT_MP_RELOAD_CROUCH_SECONDARY_END,
	ACT_MP_RELOAD_SWIM_SECONDARY,
	ACT_MP_RELOAD_SWIM_SECONDARY_LOOP,
	ACT_MP_RELOAD_SWIM_SECONDARY_END,
	ACT_MP_RELOAD_AIRWALK_SECONDARY,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_LOOP,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_END,
	ACT_MP_ATTACK_STAND_GRENADE_SECONDARY,
	ACT_MP_ATTACK_CROUCH_GRENADE_SECONDARY,
	ACT_MP_ATTACK_SWIM_GRENADE_SECONDARY,
	ACT_MP_ATTACK_AIRWALK_GRENADE_SECONDARY,
	ACT_MP_STAND_MELEE,
	ACT_MP_CROUCH_MELEE,
	ACT_MP_RUN_MELEE,
	ACT_MP_WALK_MELEE,
	ACT_MP_AIRWALK_MELEE,
	ACT_MP_CROUCHWALK_MELEE,
	ACT_MP_JUMP_MELEE,
	ACT_MP_JUMP_START_MELEE,
	ACT_MP_JUMP_FLOAT_MELEE,
	ACT_MP_JUMP_LAND_MELEE,
	ACT_MP_SWIM_MELEE,
	ACT_MP_ATTACK_STAND_MELEE,
	ACT_MP_ATTACK_STAND_MELEE_SECONDARY,
	ACT_MP_ATTACK_CROUCH_MELEE,
	ACT_MP_ATTACK_CROUCH_MELEE_SECONDARY,
	ACT_MP_ATTACK_SWIM_MELEE,
	ACT_MP_ATTACK_AIRWALK_MELEE,
	ACT_MP_ATTACK_STAND_GRENADE_MELEE,
	ACT_MP_ATTACK_CROUCH_GRENADE_MELEE,
	ACT_MP_ATTACK_SWIM_GRENADE_MELEE,
	ACT_MP_ATTACK_AIRWALK_GRENADE_MELEE,
	ACT_MP_STAND_ITEM1,
	ACT_MP_CROUCH_ITEM1,
	ACT_MP_RUN_ITEM1,
	ACT_MP_WALK_ITEM1,
	ACT_MP_AIRWALK_ITEM1,
	ACT_MP_CROUCHWALK_ITEM1,
	ACT_MP_JUMP_ITEM1,
	ACT_MP_JUMP_START_ITEM1,
	ACT_MP_JUMP_FLOAT_ITEM1,
	ACT_MP_JUMP_LAND_ITEM1,
	ACT_MP_SWIM_ITEM1,
	ACT_MP_ATTACK_STAND_ITEM1,
	ACT_MP_ATTACK_STAND_ITEM1_SECONDARY,
	ACT_MP_ATTACK_CROUCH_ITEM1,
	ACT_MP_ATTACK_CROUCH_ITEM1_SECONDARY,
	ACT_MP_ATTACK_SWIM_ITEM1,
	ACT_MP_ATTACK_AIRWALK_ITEM1,
	ACT_MP_STAND_ITEM2,
	ACT_MP_CROUCH_ITEM2,
	ACT_MP_RUN_ITEM2,
	ACT_MP_WALK_ITEM2,
	ACT_MP_AIRWALK_ITEM2,
	ACT_MP_CROUCHWALK_ITEM2,
	ACT_MP_JUMP_ITEM2,
	ACT_MP_JUMP_START_ITEM2,
	ACT_MP_JUMP_FLOAT_ITEM2,
	ACT_MP_JUMP_LAND_ITEM2,
	ACT_MP_SWIM_ITEM2,
	ACT_MP_ATTACK_STAND_ITEM2,
	ACT_MP_ATTACK_STAND_ITEM2_SECONDARY,
	ACT_MP_ATTACK_CROUCH_ITEM2,
	ACT_MP_ATTACK_CROUCH_ITEM2_SECONDARY,
	ACT_MP_ATTACK_SWIM_ITEM2,
	ACT_MP_ATTACK_AIRWALK_ITEM2,
	ACT_MP_GESTURE_FLINCH,
	ACT_MP_GESTURE_FLINCH_PRIMARY,
	ACT_MP_GESTURE_FLINCH_SECONDARY,
	ACT_MP_GESTURE_FLINCH_MELEE,
	ACT_MP_GESTURE_FLINCH_ITEM1,
	ACT_MP_GESTURE_FLINCH_ITEM2,
	ACT_MP_GESTURE_FLINCH_HEAD,
	ACT_MP_GESTURE_FLINCH_CHEST,
	ACT_MP_GESTURE_FLINCH_STOMACH,
	ACT_MP_GESTURE_FLINCH_LEFTARM,
	ACT_MP_GESTURE_FLINCH_RIGHTARM,
	ACT_MP_GESTURE_FLINCH_LEFTLEG,
	ACT_MP_GESTURE_FLINCH_RIGHTLEG,
	ACT_MP_GRENADE1_DRAW,
	ACT_MP_GRENADE1_IDLE,
	ACT_MP_GRENADE1_ATTACK,
	ACT_MP_GRENADE2_DRAW,
	ACT_MP_GRENADE2_IDLE,
	ACT_MP_GRENADE2_ATTACK,
	ACT_MP_PRIMARY_GRENADE1_DRAW,
	ACT_MP_PRIMARY_GRENADE1_IDLE,
	ACT_MP_PRIMARY_GRENADE1_ATTACK,
	ACT_MP_PRIMARY_GRENADE2_DRAW,
	ACT_MP_PRIMARY_GRENADE2_IDLE,
	ACT_MP_PRIMARY_GRENADE2_ATTACK,
	ACT_MP_SECONDARY_GRENADE1_DRAW,
	ACT_MP_SECONDARY_GRENADE1_IDLE,
	ACT_MP_SECONDARY_GRENADE1_ATTACK,
	ACT_MP_SECONDARY_GRENADE2_DRAW,
	ACT_MP_SECONDARY_GRENADE2_IDLE,
	ACT_MP_SECONDARY_GRENADE2_ATTACK,
	ACT_MP_MELEE_GRENADE1_DRAW,
	ACT_MP_MELEE_GRENADE1_IDLE,
	ACT_MP_MELEE_GRENADE1_ATTACK,
	ACT_MP_MELEE_GRENADE2_DRAW,
	ACT_MP_MELEE_GRENADE2_IDLE,
	ACT_MP_MELEE_GRENADE2_ATTACK,
	ACT_MP_ITEM1_GRENADE1_DRAW,
	ACT_MP_ITEM1_GRENADE1_IDLE,
	ACT_MP_ITEM1_GRENADE1_ATTACK,
	ACT_MP_ITEM1_GRENADE2_DRAW,
	ACT_MP_ITEM1_GRENADE2_IDLE,
	ACT_MP_ITEM1_GRENADE2_ATTACK,
	ACT_MP_ITEM2_GRENADE1_DRAW,
	ACT_MP_ITEM2_GRENADE1_IDLE,
	ACT_MP_ITEM2_GRENADE1_ATTACK,
	ACT_MP_ITEM2_GRENADE2_DRAW,
	ACT_MP_ITEM2_GRENADE2_IDLE,
	ACT_MP_ITEM2_GRENADE2_ATTACK,
	ACT_MP_STAND_BUILDING,
	ACT_MP_CROUCH_BUILDING,
	ACT_MP_RUN_BUILDING,
	ACT_MP_WALK_BUILDING,
	ACT_MP_AIRWALK_BUILDING,
	ACT_MP_CROUCHWALK_BUILDING,
	ACT_MP_JUMP_BUILDING,
	ACT_MP_JUMP_START_BUILDING,
	ACT_MP_JUMP_FLOAT_BUILDING,
	ACT_MP_JUMP_LAND_BUILDING,
	ACT_MP_SWIM_BUILDING,
	ACT_MP_ATTACK_STAND_BUILDING,
	ACT_MP_ATTACK_CROUCH_BUILDING,
	ACT_MP_ATTACK_SWIM_BUILDING,
	ACT_MP_ATTACK_AIRWALK_BUILDING,
	ACT_MP_ATTACK_STAND_GRENADE_BUILDING,
	ACT_MP_ATTACK_CROUCH_GRENADE_BUILDING,
	ACT_MP_ATTACK_SWIM_GRENADE_BUILDING,
	ACT_MP_ATTACK_AIRWALK_GRENADE_BUILDING,
	ACT_MP_STAND_PDA,
	ACT_MP_CROUCH_PDA,
	ACT_MP_RUN_PDA,
	ACT_MP_WALK_PDA,
	ACT_MP_AIRWALK_PDA,
	ACT_MP_CROUCHWALK_PDA,
	ACT_MP_JUMP_PDA,
	ACT_MP_JUMP_START_PDA,
	ACT_MP_JUMP_FLOAT_PDA,
	ACT_MP_JUMP_LAND_PDA,
	ACT_MP_SWIM_PDA,
	ACT_MP_ATTACK_STAND_PDA,
	ACT_MP_ATTACK_SWIM_PDA,
	ACT_MP_GESTURE_VC_HANDMOUTH,
	ACT_MP_GESTURE_VC_FINGERPOINT,
	ACT_MP_GESTURE_VC_FISTPUMP,
	ACT_MP_GESTURE_VC_THUMBSUP,
	ACT_MP_GESTURE_VC_NODYES,
	ACT_MP_GESTURE_VC_NODNO,
	ACT_MP_GESTURE_VC_HANDMOUTH_PRIMARY,
	ACT_MP_GESTURE_VC_FINGERPOINT_PRIMARY,
	ACT_MP_GESTURE_VC_FISTPUMP_PRIMARY,
	ACT_MP_GESTURE_VC_THUMBSUP_PRIMARY,
	ACT_MP_GESTURE_VC_NODYES_PRIMARY,
	ACT_MP_GESTURE_VC_NODNO_PRIMARY,
	ACT_MP_GESTURE_VC_HANDMOUTH_SECONDARY,
	ACT_MP_GESTURE_VC_FINGERPOINT_SECONDARY,
	ACT_MP_GESTURE_VC_FISTPUMP_SECONDARY,
	ACT_MP_GESTURE_VC_THUMBSUP_SECONDARY,
	ACT_MP_GESTURE_VC_NODYES_SECONDARY,
	ACT_MP_GESTURE_VC_NODNO_SECONDARY,
	ACT_MP_GESTURE_VC_HANDMOUTH_MELEE,
	ACT_MP_GESTURE_VC_FINGERPOINT_MELEE,
	ACT_MP_GESTURE_VC_FISTPUMP_MELEE,
	ACT_MP_GESTURE_VC_THUMBSUP_MELEE,
	ACT_MP_GESTURE_VC_NODYES_MELEE,
	ACT_MP_GESTURE_VC_NODNO_MELEE,
	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM1,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM1,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM1,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM1,
	ACT_MP_GESTURE_VC_NODYES_ITEM1,
	ACT_MP_GESTURE_VC_NODNO_ITEM1,
	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM2,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM2,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM2,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM2,
	ACT_MP_GESTURE_VC_NODYES_ITEM2,
	ACT_MP_GESTURE_VC_NODNO_ITEM2,
	ACT_MP_GESTURE_VC_HANDMOUTH_BUILDING,
	ACT_MP_GESTURE_VC_FINGERPOINT_BUILDING,
	ACT_MP_GESTURE_VC_FISTPUMP_BUILDING,
	ACT_MP_GESTURE_VC_THUMBSUP_BUILDING,
	ACT_MP_GESTURE_VC_NODYES_BUILDING,
	ACT_MP_GESTURE_VC_NODNO_BUILDING,
	ACT_MP_GESTURE_VC_HANDMOUTH_PDA,
	ACT_MP_GESTURE_VC_FINGERPOINT_PDA,
	ACT_MP_GESTURE_VC_FISTPUMP_PDA,
	ACT_MP_GESTURE_VC_THUMBSUP_PDA,
	ACT_MP_GESTURE_VC_NODYES_PDA,
	ACT_MP_GESTURE_VC_NODNO_PDA,
	ACT_VM_UNUSABLE,
	ACT_VM_UNUSABLE_TO_USABLE,
	ACT_VM_USABLE_TO_UNUSABLE,
	ACT_PRIMARY_VM_DRAW,
	ACT_PRIMARY_VM_HOLSTER,
	ACT_PRIMARY_VM_IDLE,
	ACT_PRIMARY_VM_PULLBACK,
	ACT_PRIMARY_VM_PRIMARYATTACK,
	ACT_PRIMARY_VM_SECONDARYATTACK,
	ACT_PRIMARY_VM_RELOAD,
	ACT_PRIMARY_VM_DRYFIRE,
	ACT_PRIMARY_VM_IDLE_TO_LOWERED,
	ACT_PRIMARY_VM_IDLE_LOWERED,
	ACT_PRIMARY_VM_LOWERED_TO_IDLE,
	ACT_SECONDARY_VM_DRAW,
	ACT_SECONDARY_VM_HOLSTER,
	ACT_SECONDARY_VM_IDLE,
	ACT_SECONDARY_VM_PULLBACK,
	ACT_SECONDARY_VM_PRIMARYATTACK,
	ACT_SECONDARY_VM_SECONDARYATTACK,
	ACT_SECONDARY_VM_RELOAD,
	ACT_SECONDARY_VM_DRYFIRE,
	ACT_SECONDARY_VM_IDLE_TO_LOWERED,
	ACT_SECONDARY_VM_IDLE_LOWERED,
	ACT_SECONDARY_VM_LOWERED_TO_IDLE,
	ACT_MELEE_VM_DRAW,
	ACT_MELEE_VM_HOLSTER,
	ACT_MELEE_VM_IDLE,
	ACT_MELEE_VM_PULLBACK,
	ACT_MELEE_VM_PRIMARYATTACK,
	ACT_MELEE_VM_SECONDARYATTACK,
	ACT_MELEE_VM_RELOAD,
	ACT_MELEE_VM_DRYFIRE,
	ACT_MELEE_VM_IDLE_TO_LOWERED,
	ACT_MELEE_VM_IDLE_LOWERED,
	ACT_MELEE_VM_LOWERED_TO_IDLE,
	ACT_PDA_VM_DRAW,
	ACT_PDA_VM_HOLSTER,
	ACT_PDA_VM_IDLE,
	ACT_PDA_VM_PULLBACK,
	ACT_PDA_VM_PRIMARYATTACK,
	ACT_PDA_VM_SECONDARYATTACK,
	ACT_PDA_VM_RELOAD,
	ACT_PDA_VM_DRYFIRE,
	ACT_PDA_VM_IDLE_TO_LOWERED,
	ACT_PDA_VM_IDLE_LOWERED,
	ACT_PDA_VM_LOWERED_TO_IDLE,
	ACT_ITEM1_VM_DRAW,
	ACT_ITEM1_VM_HOLSTER,
	ACT_ITEM1_VM_IDLE,
	ACT_ITEM1_VM_PULLBACK,
	ACT_ITEM1_VM_PRIMARYATTACK,
	ACT_ITEM1_VM_SECONDARYATTACK,
	ACT_ITEM1_VM_RELOAD,
	ACT_ITEM1_VM_DRYFIRE,
	ACT_ITEM1_VM_IDLE_TO_LOWERED,
	ACT_ITEM1_VM_IDLE_LOWERED,
	ACT_ITEM1_VM_LOWERED_TO_IDLE,
	ACT_ITEM2_VM_DRAW,
	ACT_ITEM2_VM_HOLSTER,
	ACT_ITEM2_VM_IDLE,
	ACT_ITEM2_VM_PULLBACK,
	ACT_ITEM2_VM_PRIMARYATTACK,
	ACT_ITEM2_VM_SECONDARYATTACK,
	ACT_ITEM2_VM_RELOAD,
	ACT_ITEM2_VM_DRYFIRE,
	ACT_ITEM2_VM_IDLE_TO_LOWERED,
	ACT_ITEM2_VM_IDLE_LOWERED,
	ACT_ITEM2_VM_LOWERED_TO_IDLE,
	ACT_RELOAD_SUCCEED,
	ACT_RELOAD_FAIL,
	ACT_WALK_AIM_AUTOGUN,
	ACT_RUN_AIM_AUTOGUN,
	ACT_IDLE_AUTOGUN,
	ACT_IDLE_AIM_AUTOGUN,
	ACT_RELOAD_AUTOGUN,
	ACT_CROUCH_IDLE_AUTOGUN,
	ACT_RANGE_ATTACK_AUTOGUN,
	ACT_JUMP_AUTOGUN,
	ACT_IDLE_AIM_PISTOL,
	ACT_WALK_AIM_DUAL,
	ACT_RUN_AIM_DUAL,
	ACT_IDLE_DUAL,
	ACT_IDLE_AIM_DUAL,
	ACT_RELOAD_DUAL,
	ACT_CROUCH_IDLE_DUAL,
	ACT_RANGE_ATTACK_DUAL,
	ACT_JUMP_DUAL,
	ACT_IDLE_SHOTGUN,
	ACT_IDLE_AIM_SHOTGUN,
	ACT_CROUCH_IDLE_SHOTGUN,
	ACT_JUMP_SHOTGUN,
	ACT_IDLE_AIM_RIFLE,
	ACT_RELOAD_RIFLE,
	ACT_CROUCH_IDLE_RIFLE,
	ACT_RANGE_ATTACK_RIFLE,
	ACT_JUMP_RIFLE,
	ACT_SLEEP,
	ACT_WAKE,
	ACT_FLICK_LEFT,
	ACT_FLICK_LEFT_MIDDLE,
	ACT_FLICK_RIGHT_MIDDLE,
	ACT_FLICK_RIGHT,
	ACT_SPINAROUND,
	ACT_PREP_TO_FIRE,
	ACT_FIRE,
	ACT_FIRE_RECOVER,
	ACT_SPRAY,
	ACT_PREP_EXPLODE,
	ACT_EXPLODE,
	ACT_DOTA_IDLE,
	ACT_DOTA_RUN,
	ACT_DOTA_ATTACK,
	ACT_DOTA_ATTACK_EVENT,
	ACT_DOTA_DIE,
	ACT_DOTA_FLINCH,
	ACT_DOTA_DISABLED,
	ACT_DOTA_CAST_ABILITY_1,
	ACT_DOTA_CAST_ABILITY_2,
	ACT_DOTA_CAST_ABILITY_3,
	ACT_DOTA_CAST_ABILITY_4,
	ACT_DOTA_OVERRIDE_ABILITY_1,
	ACT_DOTA_OVERRIDE_ABILITY_2,
	ACT_DOTA_OVERRIDE_ABILITY_3,
	ACT_DOTA_OVERRIDE_ABILITY_4,
	ACT_DOTA_CHANNEL_ABILITY_1,
	ACT_DOTA_CHANNEL_ABILITY_2,
	ACT_DOTA_CHANNEL_ABILITY_3,
	ACT_DOTA_CHANNEL_ABILITY_4,
	ACT_DOTA_CHANNEL_END_ABILITY_1,
	ACT_DOTA_CHANNEL_END_ABILITY_2,
	ACT_DOTA_CHANNEL_END_ABILITY_3,
	ACT_DOTA_CHANNEL_END_ABILITY_4,
	ACT_MP_RUN_SPEEDPAINT,
	ACT_MP_LONG_FALL,
	ACT_MP_TRACTORBEAM_FLOAT,
	ACT_MP_DEATH_CRUSH,
	ACT_MP_RUN_SPEEDPAINT_PRIMARY,
	ACT_MP_DROWNING_PRIMARY,
	ACT_MP_LONG_FALL_PRIMARY,
	ACT_MP_TRACTORBEAM_FLOAT_PRIMARY,
	ACT_MP_DEATH_CRUSH_PRIMARY,
	ACT_DIE_STAND,
	ACT_DIE_STAND_HEADSHOT,
	ACT_DIE_CROUCH,
	ACT_DIE_CROUCH_HEADSHOT,
	ACT_CSGO_NULL,
	ACT_CSGO_DEFUSE,
	ACT_CSGO_DEFUSE_WITH_KIT,
	ACT_CSGO_FLASHBANG_REACTION,
	ACT_CSGO_FIRE_PRIMARY,
	ACT_CSGO_FIRE_PRIMARY_OPT_1,
	ACT_CSGO_FIRE_PRIMARY_OPT_2,
	ACT_CSGO_FIRE_SECONDARY,
	ACT_CSGO_FIRE_SECONDARY_OPT_1,
	ACT_CSGO_FIRE_SECONDARY_OPT_2,
	ACT_CSGO_RELOAD,
	ACT_CSGO_RELOAD_START,
	ACT_CSGO_RELOAD_LOOP,
	ACT_CSGO_RELOAD_END,
	ACT_CSGO_OPERATE,
	ACT_CSGO_DEPLOY,
	ACT_CSGO_CATCH,
	ACT_CSGO_SILENCER_DETACH,
	ACT_CSGO_SILENCER_ATTACH,
	ACT_CSGO_TWITCH,
	ACT_CSGO_TWITCH_BUYZONE,
	ACT_CSGO_PLANT_BOMB,
	ACT_CSGO_IDLE_TURN_BALANCEADJUST,
	ACT_CSGO_IDLE_ADJUST_STOPPEDMOVING,
	ACT_CSGO_ALIVE_LOOP,
	ACT_CSGO_FLINCH,
	ACT_CSGO_FLINCH_HEAD,
	ACT_CSGO_FLINCH_MOLOTOV,
	ACT_CSGO_JUMP,
	ACT_CSGO_FALL,
	ACT_CSGO_CLIMB_LADDER,
	ACT_CSGO_LAND_LIGHT,
	ACT_CSGO_LAND_HEAVY,
	ACT_CSGO_EXIT_LADDER_TOP,
	ACT_CSGO_EXIT_LADDER_BOTTOM,
};

enum PlayerFlags_t : int {
	FL_ONGROUND = ( 1 << 0 ),
	FL_DUCKING = ( 1 << 1 ),
	FL_WATERJUMP = ( 1 << 3 ),
	FL_ONTRAIN = ( 1 << 4 ),
	FL_INRAIN = ( 1 << 5 ),
	FL_FROZEN = ( 1 << 6 ),
	FL_ATCONTROLS = ( 1 << 7 ),
	FL_CLIENT = ( 1 << 8 ),
	FL_FAKECLIENT = ( 1 << 9 ),
	FL_INWATER = ( 1 << 10 ),
};

enum MoveType_t : int {
	MOVETYPE_NONE = 0,
	MOVETYPE_ISOMETRIC,
	MOVETYPE_WALK,
	MOVETYPE_STEP,
	MOVETYPE_FLY,
	MOVETYPE_FLYGRAVITY,
	MOVETYPE_VPHYSICS,
	MOVETYPE_PUSH,
	MOVETYPE_NOCLIP,
	MOVETYPE_LADDER,
	MOVETYPE_OBSERVER,
	MOVETYPE_CUSTOM,
	MOVETYPE_LAST = MOVETYPE_CUSTOM,
	MOVETYPE_MAX_BITS = 4,
};

enum Weapons_t : int {
	DEAGLE = 1,
	ELITE = 2,
	FIVESEVEN = 3,
	GLOCK = 4,
	AK47 = 7,
	AUG = 8,
	AWP = 9,
	FAMAS = 10,
	G3SG1 = 11,
	GALIL = 13,
	M249 = 14,
	M4A4 = 16,
	MAC10 = 17,
	P90 = 19,
	UMP45 = 24,
	XM1014 = 25,
	BIZON = 26,
	MAG7 = 27,
	NEGEV = 28,
	SAWEDOFF = 29,
	TEC9 = 30,
	ZEUS = 31,
	P2000 = 32,
	MP7 = 33,
	MP9 = 34,
	NOVA = 35,
	P250 = 36,
	SCAR20 = 38,
	SG553 = 39,
	SSG08 = 40,
	KNIFE_T = 42,
	FLASHBANG = 43,
	HEGRENADE = 44,
	SMOKE = 45,
	MOLOTOV = 46,
	DECOY = 47,
	FIREBOMB = 48,
	C4 = 49,
	MUSICKIT = 58,
	KNIFE_CT = 59,
	M4A1S = 60,
	USPS = 61,
	TRADEUPCONTRACT = 62,
	CZ75A = 63,
	REVOLVER = 64,
	KNIFE_BAYONET = 500,
	KNIFE_FLIP = 505,
	KNIFE_GUT = 506,
	KNIFE_KARAMBIT = 507,
	KNIFE_M9_BAYONET = 508,
	KNIFE_HUNTSMAN = 509,
	KNIFE_FALCHION = 512,
	KNIFE_BOWIE = 514,
	KNIFE_BUTTERFLY = 515,
	KNIFE_SHADOW_DAGGERS = 516,
};

struct RenderableInstance_t {
	uint8_t m_alpha;
	__forceinline RenderableInstance_t( ) : m_alpha{ 255ui8 } { }
};

struct client_hit_verify_t {
	vec3_t position;
	float time;
	float expires;
};

class IHandleEntity {
public:
	virtual ~IHandleEntity( ) { }
	virtual void SetRefEHandle( const CBaseHandle& handle ) = 0;
	virtual const ulong_t& GetRefEHandle( ) const = 0;
};

class IClientUnknown : public IHandleEntity {
public:
	virtual void* GetCollideable( ) = 0;
	virtual void* GetClientNetworkable( ) = 0;
	virtual void* GetClientRenderable( ) = 0;
	virtual void* GetIClientEntity( ) = 0;
	virtual void* GetBaseEntity( ) = 0;
	virtual void* GetClientThinkable( ) = 0;
	virtual void* GetClientAlphaProperty( ) = 0;
};

class Entity : public IClientUnknown {
public:
	// helper methods.
	template< typename t >
	__forceinline t& get( size_t offset ) {
		return *( t* )( ( uintptr_t )this + offset );
	}

	template< typename t >
	__forceinline void set( size_t offset, const t& val ) {
		*( t* )( ( uintptr_t )this + offset ) = val;
	}

	template< typename t >
	__forceinline t as( ) {
		return ( t )this;
	}

public:
	// netvars / etc.
	__forceinline vec3_t& m_vecOrigin( ) {
		return get< vec3_t >( g_entoffsets.m_vecOrigin );
	}

	__forceinline vec3_t& m_vecOldOrigin( ) {
		return get< vec3_t >( g_entoffsets.m_vecOldOrigin );
	}

	__forceinline vec3_t& m_vecVelocity( ) {
		return get< vec3_t >( g_entoffsets.m_vecVelocity );
	}

	__forceinline vec3_t& m_vecMins( ) {
		return get< vec3_t >( g_entoffsets.m_vecMins );
	}

	__forceinline vec3_t& m_vecMaxs( ) {
		return get< vec3_t >( g_entoffsets.m_vecMaxs );
	}

	__forceinline int& m_iTeamNum( ) {
		return get< int >( g_entoffsets.m_iTeamNum );
	}

	__forceinline int& m_nSequence( ) {
		return get< int >( g_entoffsets.m_nSequence );
	}

	__forceinline float& m_flCycle( ) {
		return get< float >( g_entoffsets.m_flCycle );
	}

	__forceinline float& m_flC4Blow( ) {
		return get< float >( g_entoffsets.m_flC4Blow );
	}

	__forceinline bool& m_bBombTicking( ) {
		return get< bool >( g_entoffsets.m_bBombTicking );
	}

	__forceinline int& m_fEffects( ) {
		// todo; netvar.
		return get< int >( g_entoffsets.m_fEffects );
	}

	__forceinline int& m_nModelIndex( ) {
		return get< int >( g_entoffsets.m_nModelIndex );
	}

	__forceinline bool& m_bReadyToDraw( ) {
		return get< bool >( g_entoffsets.m_bReadyToDraw );
	}

	__forceinline float& m_SpawnTime( ) {
		return get< float >( g_entoffsets.m_SpawnTime );
	}

	__forceinline auto& m_fireXDelta( ) {
		return get< int[ ] >( g_entoffsets.m_fireXDelta );
	}

	__forceinline auto& m_fireYDelta( ) {
		return get< int[ ] >( g_entoffsets.m_fireYDelta );
	}

	__forceinline auto& m_fireZDelta( ) {
		return get< int[ ] >( g_entoffsets.m_fireZDelta );
	}

	__forceinline auto& m_fireCount( ) {
		return get< int >( g_entoffsets.m_SpawnTime );
	}

public:
	// virtual indices
	enum indices : size_t {
		WORLDSPACECENTER = 78,
		GETMAXHEALTH = 122,
		ISPLAYER = 152,
		ISBASECOMBATWEAPON = 160,
		GETEYEPOS = 163,
	};

public:
	// virtuals.
	// renderable table.
	__forceinline void* renderable( ) {
		return ( void* )( ( uintptr_t )this + 0x4 );
	}

	__forceinline vec3_t& GetRenderOrigin( ) {
		return util::get_method< vec3_t& ( __thiscall* )( void* ) >( renderable( ), 1 )( renderable( ) );
	}

	__forceinline ang_t& GetRenderAngles( ) {
		return util::get_method< ang_t& ( __thiscall* )( void* ) >( renderable( ), 2 )( renderable( ) );
	}

	__forceinline const model_t* GetModel( ) {
		return util::get_method< const model_t* ( __thiscall* )( void* ) >( renderable( ), 8 )( renderable( ) );
	}

	__forceinline void DrawModel( int flags = STUDIO_RENDER, const RenderableInstance_t& instance = {} ) {
		return util::get_method< void( __thiscall* )( void*, int, const RenderableInstance_t& )>( renderable( ), 9 )( renderable( ), flags, instance );
	}

	__forceinline bool GameSetupBones( matrix3x4_t* out, int max, int mask, float time ) {
		return util::get_method< bool( __thiscall* )( void*, matrix3x4_t*, int, int, float )>( renderable( ), 13 )( renderable( ), out, max, mask, time );
	}

	// networkable table.
	__forceinline void* networkable( ) {
		return ( void* )( ( uintptr_t )this + 0x8 );
	}

	__forceinline void Release( ) {
		return util::get_method< void( __thiscall* )( void* ) >( networkable( ), 1 )( networkable( ) );
	}

	__forceinline ClientClass* GetClientClass( ) {
		return util::get_method< ClientClass* ( __thiscall* )( void* ) >( networkable( ), 2 )( networkable( ) );
	}

	__forceinline void OnDataChanged( DataUpdateType_t type ) {
		return util::get_method< void( __thiscall* )( void*, DataUpdateType_t ) >( networkable( ), 5 )( networkable( ), type );
	}

	__forceinline void PreDataUpdate( DataUpdateType_t type ) {
		return util::get_method< void( __thiscall* )( void*, DataUpdateType_t ) >( networkable( ), 6 )( networkable( ), type );
	}

	__forceinline void PostDataUpdate( DataUpdateType_t type ) {
		return util::get_method< void( __thiscall* )( void*, DataUpdateType_t ) >( networkable( ), 7 )( networkable( ), type );
	}

	__forceinline bool dormant( ) {
		return util::get_method< bool( __thiscall* )( void* ) >( networkable( ), 9 )( networkable( ) );
	}

	__forceinline int index( ) {
		return *( int* )( uintptr_t( this ) + 0x64 );//util::get_method< int( __thiscall* )( void* ) >( networkable( ), 10 )( networkable( ) );
	}

	__forceinline void SetDestroyedOnRecreateEntities( ) {
		return util::get_method< void( __thiscall* )( void* ) >( networkable( ), 13 )( networkable( ) );
	}

	// normal table.
	__forceinline const vec3_t& GetAbsOrigin( ) {
		return util::get_method< const vec3_t& ( __thiscall* )( void* ) >( this, 10 )( this );
	}

	__forceinline const ang_t& GetAbsAngles( ) {
		return util::get_method< const ang_t& ( __thiscall* )( void* ) >( this, 11 )( this );
	}

	__forceinline bool IsPlayer( ) {
		return util::get_method< bool( __thiscall* )( void* ) >( this, ISPLAYER )( this );
	}

	__forceinline bool IsBaseCombatWeapon( ) {
		return util::get_method< bool( __thiscall* )( void* ) >( this, ISBASECOMBATWEAPON )( this );
	}

	__forceinline void* collideable( ) {
		return util::get_method< void* ( __thiscall* )( void* ) >( this, 3 )( this );
	}

	__forceinline std::string GetBombsiteName( ) {
		std::string out;

		// note - dex; bomb_target + 0x150 has a char array for site name... not sure how much memory gets allocated for it.
		out.resize( 32u );

		std::memcpy( &out[ 0 ], ( const void* )( ( uintptr_t )this + 0x150 ), 32u );

		return out;
	}

	__forceinline void InvalidatePhysicsRecursive( InvalidatePhysicsBits_t bits ) {
		using InvalidatePhysicsRecursive_t = void( __thiscall* )( decltype( this ), InvalidatePhysicsBits_t );
		g_csgo.InvalidatePhysicsRecursive.as< InvalidatePhysicsRecursive_t >( )( this, bits );
	}

	__forceinline void SetAbsAngles( const ang_t& angles ) {
		using SetAbsAngles_t = void( __thiscall* )( decltype( this ), const ang_t& );
		g_csgo.SetAbsAngles.as< SetAbsAngles_t >( )( this, angles );
	}

	__forceinline void SetAbsOrigin( const vec3_t& origin ) {
		using SetAbsOrigin_t = void( __thiscall* )( decltype( this ), const vec3_t& );
		g_csgo.SetAbsOrigin.as< SetAbsOrigin_t >( )( this, origin );
	}

	__forceinline void SetAbsVelocity( const vec3_t& velocity ) {
		using SetAbsVelocity_t = void( __thiscall* )( decltype( this ), const vec3_t& );
		g_csgo.SetAbsVelocity.as< SetAbsVelocity_t >( )( this, velocity );
	}

	__forceinline void AddEffect( int effects ) {
		m_fEffects( ) |= effects;
	}

	__forceinline int get_class_id( ) {
		ClientClass* cc{ GetClientClass( ) };

		return ( cc ) ? cc->m_ClassID : -1;
	}

	__forceinline bool is( hash32_t hash ) {
		return g_netvars.GetClientID( hash ) == get_class_id( );
	}
	int GetPropInt(hash32_t table, hash32_t var)
	{
		static auto offset = g_netvars.get(table, var);
		int val = *(int*)(uintptr_t(this) + (int)offset);
		return val;
	}
	float GetPropFloat(hash32_t table, hash32_t var)
	{
		static auto offset = g_netvars.get(table, var);
		float val = *(float*)(uintptr_t(this) + (int)offset);
		return val;
	}
	bool GetPropBool(hash32_t table, hash32_t var)
	{
		static auto offset = g_netvars.get(table, var);
		bool val = *(bool*)(uintptr_t(this) + (int)offset);
		return val;
	}
	

	void SetPropInt(hash32_t table, hash32_t var, int val)
	{
		*reinterpret_cast<int*>(uintptr_t(this) + (int)g_netvars.get(table, var)) = val;
	}
	void SetPropFloat(hash32_t table, hash32_t var, float val)
	{
		*reinterpret_cast<float*>(uintptr_t(this) + (int)g_netvars.get(table, var)) = val;
	}
	void SetPropBool(hash32_t hash, hash32_t var, bool val)
	{
		*reinterpret_cast<float*>(uintptr_t(this) + (int)g_netvars.get(hash, var)) = val;
	}
};

enum animstate_pose_param_idx_t {
	PLAYER_POSE_PARAM_FIRST = 0,
	PLAYER_POSE_PARAM_LEAN_YAW = PLAYER_POSE_PARAM_FIRST,
	PLAYER_POSE_PARAM_SPEED,
	PLAYER_POSE_PARAM_LADDER_SPEED,
	PLAYER_POSE_PARAM_LADDER_YAW,
	PLAYER_POSE_PARAM_MOVE_YAW,
	PLAYER_POSE_PARAM_RUN,
	PLAYER_POSE_PARAM_BODY_YAW,
	PLAYER_POSE_PARAM_BODY_PITCH,
	PLAYER_POSE_PARAM_DEATH_YAW,
	PLAYER_POSE_PARAM_STAND,
	PLAYER_POSE_PARAM_JUMP_FALL,
	PLAYER_POSE_PARAM_AIM_BLEND_STAND_IDLE,
	PLAYER_POSE_PARAM_AIM_BLEND_CROUCH_IDLE,
	PLAYER_POSE_PARAM_STRAFE_DIR,
	PLAYER_POSE_PARAM_AIM_BLEND_STAND_WALK,
	PLAYER_POSE_PARAM_AIM_BLEND_STAND_RUN,
	PLAYER_POSE_PARAM_AIM_BLEND_CROUCH_WALK,
	PLAYER_POSE_PARAM_MOVE_BLEND_WALK,
	PLAYER_POSE_PARAM_MOVE_BLEND_RUN,
	PLAYER_POSE_PARAM_MOVE_BLEND_CROUCH_WALK,
	//PLAYER_POSE_PARAM_STRAFE_CROSS,
	PLAYER_POSE_PARAM_COUNT,
};

struct animstate_pose_param_cache_t {
	bool		m_initialized;
	int			m_index;
	const char* m_name;

	animstate_pose_param_cache_t( ) {
		m_initialized = false;
		m_index = -1;
		m_name = "";
	}

	int		get_index( void );
	float	get_value( Player* pPlayer );
	void	set_value( Player* pPlayer, float flValue );
	//bool	init(C_BasePlayer* pPlayer, const char* szPoseParamName);
};

class CCSGOPlayerAnimState {
public:
	int* m_layer_order_preset = nullptr;
	bool					m_first_run_since_init = false;

	bool					m_first_foot_plant_since_init = false;
	int						m_last_update_tick = 0;
	float					m_eye_position_smooth_lerp = 0.0f;

	float					m_strafe_change_weight_smooth_fall_off = 0.0f;

	float					m_stand_walk_duration_state_has_been_valid = 0.0f;
	float					m_stand_walk_duration_state_has_been_invalid = 0.0f;
	float					m_stand_walk_how_long_to_wait_until_transition_can_blend_in = 0.0f;
	float					m_stand_walk_how_long_to_wait_until_transition_can_blend_out = 0.0f;
	float					m_stand_walk_blend_value = 0.0f;

	float					m_stand_run_duration_state_has_been_valid = 0.0f;
	float					m_stand_run_duration_state_has_been_invalid = 0.0f;
	float					m_stand_run_how_long_to_wait_until_transition_can_blend_in = 0.0f;
	float					m_stand_run_how_long_to_wait_until_transition_can_blend_out = 0.0f;
	float					m_stand_run_blend_value = 0.0f;

	float					m_crouch_walk_duration_state_has_been_valid = 0.0f;
	float					m_crouch_walk_duration_state_has_been_invalid = 0.0f;
	float					m_crouch_walk_how_long_to_wait_until_transition_can_blend_in = 0.0f;
	float					m_crouch_walk_how_long_to_wait_until_transition_can_blend_out = 0.0f;
	float					m_crouch_walk_blend_value = 0.0f;

	int						m_cached_model_index = 0;

	float					m_step_height_left = 0.0f;
	float					m_step_height_right = 0.0f;

	Weapon* m_weapon_last_bone_setup = nullptr;

	Player* m_player = nullptr;//0x0060 
	Weapon* m_weapon = nullptr;//0x0064
	Weapon* m_weapon_last = nullptr;//0x0068

	float					m_goal_feet_yaw;	// 0x0080

	float					m_last_update_time = 0.0f;//0x006C	
	int						m_last_update_frame = 0;//0x0070 
	float					m_last_update_increment = 0.0f;//0x0074 

	float					m_eye_yaw = 0.0f; //0x0078 
	float					m_eye_pitch = 0.0f; //0x007C 
	float					m_abs_yaw = 0.0f; //0x0080 
	float					m_abs_yaw_last = 0.0f; //0x0084 
	float					m_move_yaw = 0.0f; //0x0088 
	float					m_move_yaw_ideal = 0.0f; //0x008C 
	float					m_move_yaw_current_to_ideal = 0.0f; //0x0090 	
	float					m_time_to_align_lower_body;

	float					m_primary_cycle = 0.0f; //0x0098
	float					m_move_weight = 0.0f; //0x009C 

	float					m_move_weight_smoothed = 0.0f;
	float					m_anim_duck_amount = 0.0f; //0x00A4
	float					m_duck_additional = 0.0f; //0x00A8
	float					m_recrouch_weight = 0.0f;

	vec3_t					m_position_current = vec3_t( 0, 0, 0 ); //0x00B0
	vec3_t					m_position_last = vec3_t( 0, 0, 0 ); //0x00BC 

	vec3_t					m_velocity = vec3_t( 0, 0, 0 ); //0x00C8
	vec3_t					m_velocity_normalized = vec3_t( 0, 0, 0 ); // 
	vec3_t					m_velocity_normalized_non_zero = vec3_t( 0, 0, 0 ); //0x00E0
	float					m_velocity_length_xy = 0.0f; //0x00EC
	float					m_velocity_length_z = 0.0f; //0x00F0

	float					m_speed_as_portion_of_run_top_speed = 0.0f; //0x00F4
	float					m_speed_as_portion_of_walk_top_speed = 0.0f; //0x00F8 
	float					m_speed_as_portion_of_crouch_top_speed = 0.0f; //0x00FC

	float					m_min_pitch;        // 0x033C

	float					m_duration_moving = 0.0f; //0x0100
	float					m_duration_still = 0.0f; //0x0104

	bool					m_on_ground = false; //0x0108 

	bool					m_landing = false; //0x0109
	float					m_jump_to_fall = 0.0f;
	float					m_duration_in_air = 0.0f; //0x0110
	float					m_left_ground_height = 0.0f; //0x0114 
	float					m_land_anim_multiplier = 0.0f; //0x0118 

	float					m_walk_run_transition = 0.0f; //0x011C

	bool					m_landed_on_ground_this_frame = false;
	bool					m_left_the_ground_this_frame = false;
	float					m_in_air_smooth_value = 0.0f;

	bool					m_on_ladder = false; //0x0124
	float					m_ladder_weight = 0.0f; //0x0128
	float					m_ladder_speed = 0.0f;

	bool					m_walk_to_run_transition_state = false;

	bool					m_defuse_started = false;
	bool					m_plant_anim_started = false;
	bool					m_twitch_anim_started = false;
	bool					m_adjust_started = false;

	char					m_activity_modifiers_server[ 20 ] = {};
	//CUtlVector<CUtlSymbol>	m_activity_modifiers;

	float					m_next_twitch_time = 0.0f;

	float					m_time_of_last_known_injury = 0.0f;

	float					m_last_velocity_test_time = 0.0f;
	vec3_t					m_velocity_last = vec3_t( 0, 0, 0 );
	vec3_t					m_target_acceleration = vec3_t( 0, 0, 0 );
	vec3_t					m_acceleration = vec3_t( 0, 0, 0 );
	float					m_acceleration_weight = 0.0f;

	float					m_aim_matrix_transition = 0.0f;
	float					m_aim_matrix_transition_delay = 0.0f;

	bool					m_flashed = false;

	float					m_strafe_change_weight = 0.0f;
	float					m_strafe_change_target_weight = 0.0f;
	float					m_strafe_change_cycle = 0.0f;
	int						m_strafe_sequence = 0;
	bool					m_strafe_changing = false;
	float					m_duration_strafing = 0.0f;

	float					m_foot_lerp = 0.0f;

	bool					m_feet_crossed = false;

	bool					m_player_is_accelerating = false;

	animstate_pose_param_cache_t m_pose_param_mappings[ PLAYER_POSE_PARAM_COUNT ] = {};

	float					m_duration_move_weight_is_too_high = 0.0f;
	float					m_static_approach_speed = 0.0f;

	int						m_previous_move_state = 0;
	float					m_stutter_step = 0.0f;

	float					m_action_weight_bias_remainder = 0.0f;

	vec3_t m_foot_left_pos_anim = vec3_t( 0, 0, 0 );
	vec3_t m_foot_left_pos_anim_last = vec3_t( 0, 0, 0 );
	vec3_t m_foot_left_pos_plant = vec3_t( 0, 0, 0 );
	vec3_t m_foot_left_plant_vel = vec3_t( 0, 0, 0 );
	float m_foot_left_lock_amount = 0.0f;
	float m_foot_left_last_plant_time = 0.0f;

	vec3_t m_foot_right_pos_anim = vec3_t( 0, 0, 0 );
	vec3_t m_foot_right_pos_anim_last = vec3_t( 0, 0, 0 );
	vec3_t m_foot_right_pos_plant = vec3_t( 0, 0, 0 );
	vec3_t m_foot_right_plant_vel = vec3_t( 0, 0, 0 );
	float m_foot_right_lock_amount = 0.0f;
	float m_foot_right_last_plant_time = 0.0f;

	float					m_camera_smooth_height = 0.0f;
	bool					m_smooth_height_valid = false;
	float					m_last_time_velocity_over_ten = 0.0f;

	float					m_aim_yaw_min = 0.0f;//0x0330
	float					m_aim_yaw_max = 0.0f;//0x0334
	float					m_aim_pitch_min = 0.0f;
	float					m_aim_pitch_max = 0.0f;

	int						m_animstate_model_version = 0;
}; // size: 0x344

class CStudioHdr {
public:
	class mstudioposeparamdesc_t {
	public:
		int					sznameindex;
		__forceinline char* const name( void ) const { return ( ( char* )this ) + sznameindex; }
		int					flags;	// ????
		float				start;	// starting value
		float				end;	// ending value
		float				loop;	// looping range, 0 for no looping, 360 for rotations, etc.
	};

	studiohdr_t* m_pStudioHdr;
	void* m_pVModel;
};

class CBoneAccessor {
public:
	void* m_pAnimating;
	matrix3x4_t* m_pBones;
	int        m_ReadableBones;
	int        m_WritableBones;
};

class CBoneCache {
public:
	matrix3x4_t* m_pCachedBones;
	PAD( 0x8 );
	int        m_CachedBoneCount;
};

class Ragdoll : public Entity {
public:
	__forceinline Player* GetPlayer( ) {
		return g_csgo.m_entlist->GetClientEntityFromHandle< Player* >( m_hPlayer( ) );
	}

	__forceinline EHANDLE& m_hPlayer( ) {
		return get< EHANDLE >( g_entoffsets.m_hPlayer );
	}

	__forceinline float& m_flDeathYaw( ) {
		return get< float >( g_entoffsets.m_flDeathYaw );
	}

	__forceinline float& m_flAbsYaw( ) {
		return get< float >( g_entoffsets.m_flAbsYaw );
	}
};

class Player : public Entity {
public:
	// netvars / etc.
	__forceinline vec3_t& m_vecAbsVelocity( ) {
		return get< vec3_t >( g_entoffsets.m_vecAbsVelocity );
	}

	__forceinline int& m_lifeState( ) {
		return get< int >( g_entoffsets.m_lifeState );
	}

	__forceinline int& m_fFlags( ) {
		return get< int >( g_entoffsets.m_fFlags );
	}

	__forceinline int& m_MoveType( ) {
		return get< int >( g_entoffsets.m_MoveType );
	}

	__forceinline int& m_iHealth( ) {
		return get< int >( g_entoffsets.m_iHealth );
	}

	__forceinline int& m_iAccount( ) {
		return get< int >( g_entoffsets.m_iAccount );
	}

	__forceinline bool& m_bHasDefuser( ) {
		return get< bool >( g_entoffsets.m_bHasDefuser );
	}

	__forceinline int& m_nHitboxSet( ) {
		return get< int >( g_entoffsets.m_nHitboxSet );
	}

	__forceinline ang_t& m_angAbsRotation( ) {
		return get< ang_t >( g_entoffsets.m_angAbsRotation );
	}

	__forceinline ang_t& m_RenderAngles( ) {
		return get< ang_t >( g_entoffsets.deadflag + 4 );
	}

	__forceinline ang_t& m_angRotation( ) {
		return get< ang_t >( g_entoffsets.m_angRotation );
	}

	__forceinline ang_t& m_angNetworkAngles( ) {
		return get< ang_t >( g_entoffsets.m_angNetworkAngles );
	}

	__forceinline bool m_bIsLocalPlayer( ) {
		// .text:101E0078 674     84 C0				   test    al, al          ; Logical Compare
		// .text:101E007A 674     74 17				   jz      short loc_101E0093; Jump if Zero( ZF = 1 )
		// .text:101E007C 674     8A 83 F8 35 00 00	   mov     al, [ ebx + 35F8h ]
		return get< bool >( g_csgo.IsLocalPlayer );
	}

	__forceinline CCSGOPlayerAnimState* m_PlayerAnimState( ) {
		// .text:1037A5B8 00C     E8 E3 40 E6 FF         call    C_BasePlayer__Spawn ; Call Procedure
		// .text:1037A5BD 00C     80 BE E1 39 00 00 00   cmp     byte ptr[ esi + 39E1h ], 0; Compare Two Operands
		// .text:1037A5C4 00C     74 48                  jz      short loc_1037A60E; Jump if Zero( ZF = 1 )
		// .text:1037A5C6 00C     8B 8E 74 38 00 00      mov     ecx, [ esi + 3874h ]; this
		// .text:1037A5CC 00C     85 C9                  test    ecx, ecx; Logical Compare
		// .text:1037A5CE 00C     74 3E                  jz      short loc_1037A60E; Jump if Zero( ZF = 1 )
		return get< CCSGOPlayerAnimState* >( g_csgo.PlayerAnimState );
	}

	__forceinline CStudioHdr* m_studioHdr( ) {
		// .text:1017E902 08C    8B 86 3C 29 00 00    mov     eax, [ esi + 293Ch ]
		// .text:1017E908 08C    89 44 24 10          mov[ esp + 88h + var_78 ], eax
		return get< CStudioHdr* >( g_csgo.studioHdr );
	}

	__forceinline ulong_t& m_iMostRecentModelBoneCounter( ) {
		// .text:101AC9A9 000    89 81 80 26 00 00    mov[ ecx + 2680h ], eax
		return get< ulong_t >( g_csgo.MostRecentModelBoneCounter );
	}

	__forceinline float& m_flLastBoneSetupTime( ) {
		// .text:101AC99F 000    C7 81 14 29 00 00 FF FF+    mov     dword ptr [ecx+2914h], 0FF7FFFFFh;
		return get< float >( g_csgo.LastBoneSetupTime );
	}

	__forceinline int& m_nTickBase( ) {
		return get< int >( g_entoffsets.m_nTickBase );
	}

	__forceinline float& m_flNextAttack( ) {
		return get< float >( g_entoffsets.m_flNextAttack );
	}

	__forceinline float& m_flDuckAmount( ) {
		return get< float >( g_entoffsets.m_flDuckAmount );
	}

	__forceinline float& m_flSimulationTime( ) {
		return get< float >( g_entoffsets.m_flSimulationTime );
	}

	__forceinline float& m_flOldSimulationTime( ) {
		return get< float >( g_entoffsets.m_flOldSimulationTime );
	}

	__forceinline float& m_flLowerBodyYawTarget( ) {
		return get< float >( g_entoffsets.m_flLowerBodyYawTarget );
	}

	__forceinline float& m_fImmuneToGunGameDamageTime( ) {
		return get< float >( g_entoffsets.m_fImmuneToGunGameDamageTime );
	}

	__forceinline bool& m_bHasHelmet( ) {
		return get< bool >( g_entoffsets.m_bHasHelmet );
	}

	__forceinline bool& m_bWaitForNoAttack( ) {
		return get< bool >( g_entoffsets.m_bWaitForNoAttack );
	}

	__forceinline bool& m_bClientSideAnimation( ) {
		return get< bool >( g_entoffsets.m_bClientSideAnimation );
	}

	__forceinline bool& m_bHasHeavyArmor( ) {
		return get< bool >( g_entoffsets.m_bHasHeavyArmor );
	}

	__forceinline bool& m_bIsScoped( ) {
		return get< bool >( g_entoffsets.m_bIsScoped );
	}

	__forceinline bool& m_bDucking( ) {
		return get< bool >( g_entoffsets.m_bDucking );
	}

	__forceinline bool& m_bSpotted( ) {
		return get< bool >( g_entoffsets.m_bSpotted );
	}

	__forceinline int& m_iObserverMode( ) {
		return get< int >( g_entoffsets.m_iObserverMode );
	}

	__forceinline int& m_ArmorValue( ) {
		return get< int >( g_entoffsets.m_ArmorValue );
	}

	__forceinline float& m_flMaxspeed( ) {
		return get< float >( g_entoffsets.m_flMaxspeed );
	}

	__forceinline float& m_surfaceFriction( ) {
		return get< float >( g_entoffsets.m_surfaceFriction );
	}

	__forceinline float& m_flFlashBangTime( ) {
		return get< float >( g_entoffsets.m_flFlashBangTime );
	}

	__forceinline ang_t& m_angEyeAngles( ) {
		return get< ang_t >( g_entoffsets.m_angEyeAngles );
	}

	__forceinline ang_t& m_aimPunchAngle( ) {
		return get< ang_t >( g_entoffsets.m_aimPunchAngle );
	}

	__forceinline ang_t& m_viewPunchAngle( ) {
		return get< ang_t >( g_entoffsets.m_viewPunchAngle );
	}

	__forceinline ang_t& m_aimPunchAngleVel( ) {
		return get< ang_t >( g_entoffsets.m_aimPunchAngleVel );
	}

	__forceinline vec3_t& m_vecViewOffset( ) {
		return get< vec3_t >( g_entoffsets.m_vecViewOffset );
	}

	__forceinline CUserCmd& m_PlayerCommand( ) {
		return get< CUserCmd >( g_entoffsets.m_PlayerCommand );
	}

	__forceinline CUserCmd*& m_pCurrentCommand( ) {
		return get< CUserCmd* >( g_entoffsets.m_pCurrentCommand );
	}

	__forceinline int& m_iEFlags( ) {
		return get< int >( g_entoffsets.m_iEFlags );
	}

	__forceinline std::array<float, 24> m_flPoseParameter( ) {
		return *( std::array<float, 24>* )( ( uintptr_t )this + g_entoffsets.m_flPoseParameter );
	}

	__forceinline float& m_flGroundAccelLinearFracLastTime( ) {
		return *( float* )( ( uintptr_t )this + g_entoffsets.m_flGroundAccelLinearFracLastTime );
	}

	__forceinline float& m_flVelocityModifier( ) {
		return *( float* )( ( uintptr_t )this + g_entoffsets.m_flVelocityModifier );
	}

	__forceinline float& m_flTimeOfLastInjury( ) {
		return *( float* )( ( uintptr_t )this + g_entoffsets.m_flTimeOfLastInjury );
	}

	__forceinline CBaseHandle* m_hMyWearables( ) {
		return ( CBaseHandle* )( ( uintptr_t )this + g_entoffsets.m_hMyWearables );
	}

	__forceinline CBoneCache& m_BoneCache( ) {
		// TODO; sig
		return get< CBoneCache >( g_entoffsets.m_BoneCache );
	}

	void set_collision_bounds( const vec3_t mins, const vec3_t maxs ) {
		if( g_csgo.SetCollisionBounds && collideable( ) )
			reinterpret_cast< void( __thiscall* )( void*, const vec3_t&, const vec3_t& ) >( g_csgo.SetCollisionBounds )( collideable( ), mins, maxs );
	}

	__forceinline EHANDLE& m_hObserverTarget( ) {
		return get< EHANDLE >( g_entoffsets.m_hObserverTarget );
	}

	__forceinline EHANDLE& m_hActiveWeapon( ) {
		return get< EHANDLE >( g_entoffsets.m_hActiveWeapon );
	}

	__forceinline EHANDLE& m_hGroundEntity( ) {
		return get< EHANDLE >( g_entoffsets.m_hGroundEntity );
	}

	__forceinline CBaseHandle* m_hMyWeapons( ) {
		return ( CBaseHandle* )( ( uintptr_t )this + g_entoffsets.m_hMyWeapons );
	}

	__forceinline C_AnimationLayer* m_AnimOverlay( ) {
		// .text:1017EAB1 08C    8B 47 1C                mov     eax, [edi+1Ch]
		// .text:1017EAB4 08C    8D 0C D5 00 00 00 00    lea     ecx, ds:0[ edx * 8 ]; Load Effective Address
		// .text:1017EABB 08C    2B CA                   sub     ecx, edx; Integer Subtraction
		// .text:1017EABD 08C    8B 80 70 29 00 00       mov     eax, [ eax + 2970h ]
		// .text:1017EAC3 08C    8D 34 C8                lea     esi, [ eax + ecx * 8 ]; Load Effective Address
		// .text:1017EAC6
		return get< C_AnimationLayer* >( g_csgo.AnimOverlay );
	}

	__forceinline int m_AnimOverlayCount( ) {
		// .text:1017EAB1 08C    8B 47 1C                mov     eax, [edi+1Ch]
		// .text:1017EAB4 08C    8D 0C D5 00 00 00 00    lea     ecx, ds:0[ edx * 8 ]; Load Effective Address
		// .text:1017EABB 08C    2B CA                   sub     ecx, edx; Integer Subtraction
		// .text:1017EABD 08C    8B 80 70 29 00 00       mov     eax, [ eax + 2970h ]
		// .text:1017EAC3 08C    8D 34 C8                lea     esi, [ eax + ecx * 8 ]; Load Effective Address
		// .text:1017EAC6
		return get< int >( g_csgo.AnimOverlay + 0xC );
	}

	__forceinline float& m_flSpawnTime( ) {
		// .text:10381AB3 00C    F3 0F 10 49 10             movss   xmm1, dword ptr [ecx+10h] ; Move Scalar Single-FP
		// .text:10381AB8 00C    F3 0F 5C 88 90 A2 00 00    subss   xmm1, dword ptr[ eax + 0A290h ]; Scalar Single - FP Subtract
		return get< float >( g_csgo.SpawnTime );
	}

	__forceinline int& m_iMoveState( ) {
		return *( int* )( uintptr_t( this ) + g_entoffsets.m_iMoveState );
	}

	__forceinline bool& m_bIsWalking( ) {
		return get< bool >( g_entoffsets.m_bIsWalking );
	}

	BYTE& m_ubEFNoInterpParity( ) {
		return *( BYTE* )( uintptr_t( this ) + g_entoffsets.m_ubEFNoInterpParity );
	}

	BYTE& m_ubEFNoInterpParityOld( ) {
		return *( BYTE* )( uintptr_t( this ) + g_entoffsets.m_ubEFNoInterpParity + 1 );
	}

	__forceinline CBoneAccessor& m_BoneAccessor( ) {
		// .text:101A9253 1C4    C7 81 A0 26 00 00 00 FF 0F 00    mov     dword ptr[ ecx + 26A0h ], 0FFF00h
		// .text:101A925D 1C4    C7 81 9C 26 00 00 00 FF 0F 00    mov     dword ptr[ ecx + 269Ch ], 0FFF00h
		// .text:101A9267 1C4    8B 10                            mov     edx, [ eax ]
		// .text:101A9269 1C4    8D 81 94 26 00 00                lea     eax, [ ecx + 2694h ]; Load Effective Address
		// .text:101A926F 1C4    50                               push    eax
		return get< CBoneAccessor >( g_csgo.BoneAccessor );
	}

	void attachments_helper( CStudioHdr* hdr ) {
		using AttachmentHelperFn = void( __thiscall* )( Player*, CStudioHdr* );
		( ( AttachmentHelperFn )g_csgo.AttachementsHelper )( this, hdr );
	}

public:
	enum indices : size_t {
		GETREFEHANDLE = 2,
		TESTHITBOXES = 52,
		BUILDTRANSFORMATIONS = 184,
		DOEXTRABONEPROCESSING = 192,
		STANDARDBLENDINGRULES = 200,
		UPDATECLIENTSIDEANIMATION = 218, // 55 8B EC 51 56 8B F1 80 BE ? ? ? ? ? 74 36
		GETACTIVEWEAPON = 262,
		WEAPONSHOOTPOSITION = 277,
		GETFOV = 321,
		UPDATECOLLISIONBOUNDS = 329 // 56 57 8B F9 8B 0D ? ? ? ? F6 87 ? ? ? ? ?
	};

public:
	// virtuals.
	__forceinline ulong_t GetRefEHandle( ) {
		using GetRefEHandle_t = ulong_t( __thiscall* )( decltype( this ) );
		return util::get_method< GetRefEHandle_t >( this, GETREFEHANDLE )( this );
	}

	__forceinline void BuildTransformations( CStudioHdr* hdr, vec3_t* pos, quaternion_t* q, const matrix3x4_t& transform, int mask, uint8_t* computed ) {
		using BuildTransformations_t = void( __thiscall* )( decltype( this ), CStudioHdr*, vec3_t*, quaternion_t*, matrix3x4_t const&, int, uint8_t* );
		return util::get_method< BuildTransformations_t >( this, BUILDTRANSFORMATIONS )( this, hdr, pos, q, transform, mask, computed );
	}

	__forceinline void StandardBlendingRules( CStudioHdr* hdr, vec3_t* pos, quaternion_t* q, float time, int mask ) {
		using StandardBlendingRules_t = void( __thiscall* )( decltype( this ), CStudioHdr*, vec3_t*, quaternion_t*, float, int );
		return util::get_method< StandardBlendingRules_t >( this, STANDARDBLENDINGRULES )( this, hdr, pos, q, time, mask );
	}

	__forceinline float GetFOV( ) {
		return util::get_method< float( __thiscall* )( decltype( this ) ) >( this, GETFOV )( this );
	}

	__forceinline const vec3_t& WorldSpaceCenter( ) {
		return util::get_method< const vec3_t& ( __thiscall* )( void* ) >( this, WORLDSPACECENTER )( this );
	}

	__forceinline void GetEyePos( vec3_t* pos ) {
		util::get_method< void( __thiscall* )( decltype( this ), vec3_t* ) >( this, GETEYEPOS )( this, pos );
	}
	__forceinline vec3_t get_eye_pos()
	{
		vec3_t out;
		util::get_method<void(__thiscall*)(void*, vec3_t&)>(this, 277)(this, out);
		return out;
	}


	__forceinline void ModifyEyePosition( vec3_t* pos ) {
		if( !m_PlayerAnimState( ) ) {
			return;
		}

		//  if ( *(this + 0x50) && (*(this + 0x100) || *(this + 0x94) != 0.0 || !sub_102C9480(*(this + 0x50))) )
		if( m_PlayerAnimState( )->m_player &&
			( m_PlayerAnimState( )->m_landing || m_PlayerAnimState( )->m_player->m_flDuckAmount( ) != 0.f || !m_PlayerAnimState( )->m_player->m_hGroundEntity( ) ) ) {
			auto v5 = 8;

			if( v5 != -1 && m_PlayerAnimState( )->m_player->m_BoneCache( ).m_pCachedBones ) {
				vec3_t head_pos(
					m_PlayerAnimState( )->m_player->m_BoneCache( ).m_pCachedBones[ 8 ][ 0 ][ 3 ],
					m_PlayerAnimState( )->m_player->m_BoneCache( ).m_pCachedBones[ 8 ][ 1 ][ 3 ],
					m_PlayerAnimState( )->m_player->m_BoneCache( ).m_pCachedBones[ 8 ][ 2 ][ 3 ] );

				auto v12 = head_pos;
				auto v7 = v12.z + 1.7;

				auto v8 = pos->z;
				if( v8 > v7 ) // if (v8 > (v12 + 1.7))
				{
					float v13 = 0.f;
					float v3 = ( *pos ).z - v7;

					float v4 = ( v3 - 4.f ) * 0.16666667;
					if( v4 >= 0.f )
						v13 = std::fminf( v4, 1.f );

					( *pos ).z = ( ( ( v7 - ( *pos ).z ) ) * ( ( ( v13 * v13 ) * 3.0 ) - ( ( ( v13 * v13 ) * 2.0 ) * v13 ) ) ) + ( *pos ).z;
				}
			}
		}
	}

	__forceinline vec3_t Weapon_ShootPosition( vec3_t dummy ) {
		/*vec3_t dummy;
		dummy[2] = 0.0;
		dummy[1] = 0.0;
		dummy[0] = 0.0;

		util::get_method< vec3_t&( __thiscall* )( decltype( this ), vec3_t& ) >( this, WEAPONSHOOTPOSITION )( this, dummy );*/
		if( m_PlayerAnimState( ) && m_PlayerAnimState( )->m_player == this && ( m_PlayerAnimState( )->m_landing || m_PlayerAnimState( )->m_anim_duck_amount != 0.0f || !m_hGroundEntity( ) ) ) {
			vec3_t vecHeadPos;

			matrix3x4_t& bonetoworld = m_BoneCache( ).m_pCachedBones[ 8 ];

			vecHeadPos.x = bonetoworld[ 0 ][ 3 ];
			vecHeadPos.y = bonetoworld[ 1 ][ 3 ];
			vecHeadPos.z = bonetoworld[ 2 ][ 3 ];

			auto flHeadHeight = vecHeadPos.z + 1.7f;
			if( dummy.z > flHeadHeight ) {
				auto tmp = 0.0f;
				tmp = ( fabsf( dummy.z - flHeadHeight ) - 4.0f ) * 0.16666667f;
				if( tmp >= 0.0f )
					tmp = fminf( tmp, 1.0f );
				dummy.z = ( ( flHeadHeight - dummy.z )
							* ( ( ( tmp * tmp ) * 3.0f ) - ( ( ( tmp * tmp ) * 2.0f ) * tmp ) ) )
					+ dummy.z;
			}
		}

		return dummy;
	}

	__forceinline vec3_t GetShootPorsition( ) {
		vec3_t pos;
		GetEyePos( &pos );

		if( *reinterpret_cast < int32_t* > ( uintptr_t( this ) + 0x39E1 ) ) {
			auto v3 = m_PlayerAnimState( );
			if( v3 ) {
				ModifyEyePosition( &pos );
			}
		}

		return pos;
	}

	__forceinline void UpdateClientSideAnimation( ) {
		return util::get_method< void( __thiscall* )( decltype( this ) ) >( this, UPDATECLIENTSIDEANIMATION )( this );
	}

	__forceinline void UpdateCollisionBounds( ) {
		return util::get_method< void( __thiscall* )( decltype( this ) ) >( this, UPDATECOLLISIONBOUNDS )( this );
	}

	// misc funcs.
	__forceinline CStudioHdr* GetModelPtr( ) {
		using LockStudioHdr_t = void( __thiscall* )( decltype( this ) );

		if( !m_studioHdr( ) )
			g_csgo.LockStudioHdr.as< LockStudioHdr_t >( )( this );

		return m_studioHdr( );
	}

	__forceinline Weapon* GetActiveWeapon( ) {
		return g_csgo.m_entlist->GetClientEntityFromHandle< Weapon* >( m_hActiveWeapon( ) );
	}

	__forceinline Entity* GetObserverTarget( ) {
		return g_csgo.m_entlist->GetClientEntityFromHandle( m_hObserverTarget( ) );
	}


	__forceinline Entity* GetGroundEntiy( ) {
		return g_csgo.m_entlist->GetClientEntityFromHandle( m_hGroundEntity( ) );
	}

	__forceinline void SetAnimLayers( C_AnimationLayer* layers ) {
		std::memcpy( m_AnimOverlay( ), layers, sizeof( C_AnimationLayer ) * 13 );
	}

	__forceinline void GetAnimLayers( C_AnimationLayer* layers ) {
		std::memcpy( layers, m_AnimOverlay( ), sizeof( C_AnimationLayer ) * 13 );
	}

	__forceinline C_AnimationLayer* GetAnimOverlay( int i ) {
		if( i < 15 )
			return &m_AnimOverlay( )[ i ];
		return nullptr;
	}

	__forceinline void SetPoseParameters( float* poses ) {
		std::memcpy( m_flPoseParameter( ).data( ), poses, sizeof( float ) * 24 );
	}

	__forceinline void GetPoseParameters( float* poses ) {
		std::memcpy( poses, m_flPoseParameter( ).data( ), sizeof( float ) * 24 );
	}

	__forceinline bool ComputeHitboxSurroundingBox( vec3_t* mins, vec3_t* maxs ) {
		using ComputeHitboxSurroundingBox_t = bool( __thiscall* )( void*, vec3_t*, vec3_t* );

		return g_csgo.ComputeHitboxSurroundingBox.as< ComputeHitboxSurroundingBox_t >( )( this, mins, maxs );
	}

	__forceinline int GetSequenceActivity( int sequence ) {
		using GetSequenceActivity_t = int( __fastcall* )( CStudioHdr*, int );

		return g_csgo.GetSequenceActivity.as< GetSequenceActivity_t >( )( GetModelPtr( ), sequence );
	}

	__forceinline bool HasC4( ) {
		using HasC4_t = bool( __thiscall* )( decltype( this ) );
		return g_csgo.HasC4.as< HasC4_t >( )( this );
	}

	__forceinline void InvalidateBoneCache( ) {
		CBoneAccessor* accessor = &m_BoneAccessor( );
		if( !accessor )
			return;

		accessor->m_WritableBones = 0;
		accessor->m_ReadableBones = 0;

		m_iMostRecentModelBoneCounter( ) = 0;
		m_flLastBoneSetupTime( ) = float( 0xFF7FFFFF );
	}

	int& m_nLastNonSkippedFrame( ) {
		return *( int* )( uintptr_t( this ) + 0xA68 );
	}

	int& m_nCustomBlendingRuleMask( ) {
		return *( int* )( uintptr_t( this ) + 0xA24 );
	}

	int& m_nAnimLODflags( ) {
		return *( int* )( uintptr_t( this ) + 0xA28 );
	}

	int& m_ClientEntEffects( ) {
		return *( int* )( uintptr_t( this ) + 0x68 );
	}

	int& m_pIK( ) {
		return *( int* )( uintptr_t( this ) + ( g_entoffsets.m_nForceBone - 0x1C ) );
	}


	__forceinline bool SetupBones( matrix3x4_t* out, int max, int mask, float time, bool set_origin = false ) {

		const auto m_pIk = m_pIK( );
		const auto client_ent_flags = m_ClientEntEffects( );
		const auto effects = m_fEffects( );
		const auto animlod = m_nAnimLODflags( );
		const auto origin = GetAbsOrigin( );

		const auto bonesbk = g_csgo.r_jiggle_bones->GetInt( );
		g_csgo.r_jiggle_bones->SetValue( 0 );

		m_pIK( ) = 0;
		m_BoneAccessor( ).m_ReadableBones = 0;
		m_iMostRecentModelBoneCounter( ) = 0;
		m_nLastNonSkippedFrame( ) = 0;
		m_nAnimLODflags( ) &= ~2u; //flag: ANIMLODFLAG_OUTSIDEVIEWFRUSTUM
		m_nCustomBlendingRuleMask( ) = -1;
		m_ClientEntEffects( ) |= 2u; //flag: NO_IK
		m_fEffects( ) |= 8u;

		float prev_layer = -1;

		if( m_AnimOverlayCount( ) >= 12 ) {
			prev_layer = m_AnimOverlay( )[ 12 ].m_weight;
			m_AnimOverlay( )[ 12 ].m_weight = 0;
		}

		if( set_origin )
			SetAbsOrigin( m_vecOrigin( ) );

		const auto pastedframe = g_csgo.m_globals->m_frame;

		g_csgo.m_globals->m_frame = -999;

		auto boneSnapshot1 = ( float* )( uintptr_t( this ) + ( 0x3AD0 + 4 ) );
		auto boneSnapshot2 = ( float* )( uintptr_t( this ) + ( 0x6F20 + 4 ) );

		auto bk_snapshot1 = *boneSnapshot1;
		auto bk_snapshot2 = *boneSnapshot2;

		*boneSnapshot1 = 0.0f;
		*boneSnapshot2 = 0.0f;

		g_cl.m_updating_bones = true;
		auto bones = GameSetupBones( out, max, mask, time );
		g_cl.m_updating_bones = false;

		g_csgo.m_globals->m_frame = pastedframe;
		*boneSnapshot1 = bk_snapshot1;
		*boneSnapshot2 = bk_snapshot2;

		if( m_AnimOverlayCount( ) >= 12 && prev_layer >= 0.f ) {
			m_AnimOverlay( )[ 12 ].m_weight = prev_layer;
		}

		m_pIK( ) = m_pIk;
		m_fEffects( ) = effects;
		m_ClientEntEffects( ) = client_ent_flags;
		m_nAnimLODflags( ) = animlod;

		g_csgo.r_jiggle_bones->SetValue( bonesbk );

		if( set_origin )
			SetAbsOrigin( origin );

		return bones;
	}

	__forceinline vec3_t GetBonePosition( int iBone ) {
		matrix3x4_t boneMatrixes[ 128 ];
		if( SetupBones( boneMatrixes, 128, 0x100, 0 ) ) {
			matrix3x4_t boneMatrix = boneMatrixes[ iBone ];
			return vec3_t( boneMatrix.m_flMatVal[ 0 ][ 3 ], boneMatrix.m_flMatVal[ 1 ][ 3 ], boneMatrix.m_flMatVal[ 2 ][ 3 ] );
		}
		else
			return vec3_t( 0, 0, 0 );
	}

	__forceinline bool alive( ) {
		return m_lifeState( ) == LIFE_ALIVE;
	}

	__forceinline bool enemy( Player* from ) {
		if( m_iTeamNum( ) != from->m_iTeamNum( ) )
			return true;

		else if( g_csgo.mp_teammates_are_enemies->GetInt( ) )
			return true;

		return false;
	}

	float& get_creation_time( );
};

class WeaponInfo {
private:
	PAD( 0x4 );											// 0x0000

public:
	const char* m_weapon_name;						// 0x0004 -- actual weapon name, even for usp-s and revolver. ex: "weapon_revolver"
	PAD( 0xC );												// 0x0008
	int               m_max_clip1;							// 0x0014
	int				  m_max_clip2;							// 0x0018
	int				  m_default_clip1;						// 0x001C
	int		          m_default_clip2;						// 0x0020
	int               m_max_reserve;						// 0x0024
	PAD( 0x4 );												// 0x0028
	const char* m_world_model;						// 0x002C
	const char* m_view_model;							// 0x0030
	const char* m_world_dropped_model;				// 0x0034
	PAD( 0x48 );											// 0x0038
	const char* m_ammo_type;							// 0x0080
	uint8_t           pad_0084[ 4 ];						// 0x0084
	const char* m_sfui_name;							// 0x0088
	const char* m_deprecated_weapon_name;				// 0x008C -- shitty weapon name, shows "weapon_deagle" for revolver / etc.
	uint8_t           pad_0090[ 56 ];						// 0x0090
	CSWeaponType      m_weapon_type;						// 0x00C8
	int			      m_in_game_price;						// 0x00CC
	int               m_kill_award;							// 0x00D0
	const char* m_animation_prefix;					// 0x00D4
	float			  m_cycletime;							// 0x00D8
	float			  m_cycletime_alt;						// 0x00DC
	float			  m_time_to_idle;						// 0x00E0
	float			  m_idle_interval;						// 0x00E4
	bool			  m_is_full_auto;						// 0x00E5
	PAD( 0x3 );												// 0x00E8
	int               m_damage;								// 0x00EC
	float             m_armor_ratio;						// 0x00F0
	int               m_bullets;							// 0x00F4
	float             m_penetration;						// 0x00F8
	float             m_flinch_velocity_modifier_large;		// 0x00FC
	float             m_flinch_velocity_modifier_small;		// 0x0100
	float             m_range;								// 0x0104
	float             m_range_modifier;						// 0x0108
	float			  m_throw_velocity;						// 0x010C
	PAD( 0xC );												// 0x0118
	bool			  m_has_silencer;						// 0x0119
	PAD( 0x3 );												// 0x011C
	const char* m_silencer_model;						// 0x0120
	int				  m_crosshair_min_distance;				// 0x0124
	int				  m_crosshair_delta_distance;			// 0x0128
	float             m_max_player_speed;					// 0x012C
	float             m_max_player_speed_alt;				// 0x0130
	float			  m_spread;								// 0x0134
	float			  m_spread_alt;							// 0x0138
	float             m_inaccuracy_crouch;					// 0x013C
	float             m_inaccuracy_crouch_alt;				// 0x0140
	float             m_inaccuracy_stand;					// 0x0144
	float             m_inaccuracy_stand_alt;				// 0x0148
	float             m_inaccuracy_jump_initial;			// 0x014C
	float             m_inaccuracy_jump;					// 0x0150
	float             m_inaccuracy_jump_alt;				// 0x0154
	float             m_inaccuracy_land;					// 0x0158
	float             m_inaccuracy_land_alt;				// 0x015C
	float             m_inaccuracy_ladder;					// 0x0160
	float             m_inaccuracy_ladder_alt;				// 0x0164
	float             m_inaccuracy_fire;					// 0x0168
	float             m_inaccuracy_fire_alt;				// 0x016C
	float             m_inaccuracy_move;					// 0x0170
	float             m_inaccuracy_move_alt;				// 0x0174
	float             m_inaccuracy_reload;					// 0x0178
	int               m_recoil_seed;						// 0x017C
	float			  m_recoil_angle;						// 0x0180
	float             m_recoil_angle_alt;					// 0x0184
	float             m_recoil_angle_variance;				// 0x0188
	float             m_recoil_angle_variance_alt;			// 0x018C
	float             m_recoil_magnitude;					// 0x0190
	float             m_recoil_magnitude_alt;				// 0x0194
	float             m_recoil_magnitude_variance;			// 0x0198
	float             m_recoil_magnitude_variance_alt;		// 0x019C
	float             m_recovery_time_crouch;				// 0x01A0
	float             m_recovery_time_stand;				// 0x01A4
	float             m_recovery_time_crouch_final;			// 0x01A8
	float             m_recovery_time_stand_final;			// 0x01AC
	float             m_recovery_transition_start_bullet;	// 0x01B0
	float             m_recovery_transition_end_bullet;		// 0x01B4
	bool			  m_unzoom_after_shot;					// 0x01B5
	PAD( 0x3 );												// 0x01B8
	bool		      m_hide_view_model_zoomed;				// 0x01B9
	bool			  m_zoom_levels;						// 0x01BA
	PAD( 0x2 );												// 0x01BC
	int				  m_zoom_fov[ 2 ];						// 0x01C4
	float			  m_zoom_time[ 3 ];						// 0x01D0
	PAD( 0x8 );												// 0x01D8
	float             m_addon_scale;						// 0x01DC
	PAD( 0x8 );												// 0x01E4
	int				  m_tracer_frequency;					// 0x01E8
	int				  m_tracer_frequency_alt;				// 0x01EC
	PAD( 0x18 );											// 0x0200
	int				  m_health_per_shot;					// 0x0204
	PAD( 0x8 );												// 0x020C
	float			  m_inaccuracy_pitch_shift;				// 0x0210
	float			  m_inaccuracy_alt_sound_threshold;		// 0x0214
	float			  m_bot_audible_range;					// 0x0218
	PAD( 0x8 );												// 0x0220
	const char* m_wrong_team_msg;						// 0x0224
	bool			  m_has_burst_mode;						// 0x0225
	PAD( 0x3 );												// 0x0228
	bool			  m_is_revolver;						// 0x0229
	bool			  m_can_shoot_underwater;				// 0x022A
	PAD( 0x2 );												// 0x022C			
};

class IRefCounted {
private:
	volatile long refCount;

public:
	virtual void destructor( char bDelete ) = 0;
	virtual bool OnFinalRelease( ) = 0;

	void unreference( ) {
		if( InterlockedDecrement( &refCount ) == 0 && OnFinalRelease( ) ) {
			destructor( 1 );
		}
	}
};

class Weapon : public Entity {
public:
	using ref_vec_t = CUtlVector< IRefCounted* >;

	// netvars / etc.
	__forceinline ref_vec_t& m_CustomMaterials( ) {
		return get< ref_vec_t >( g_entoffsets.m_CustomMaterials );
	}

	__forceinline ref_vec_t& m_CustomMaterials2( ) {
		return get< ref_vec_t >( g_entoffsets.m_CustomMaterials2 );
	}

	__forceinline ref_vec_t& m_VisualsDataProcessors( ) {
		return get< ref_vec_t >( g_entoffsets.m_VisualsDataProcessors );
	}

	__forceinline bool& m_bCustomMaterialInitialized( ) {
		return get< bool >( g_entoffsets.m_bCustomMaterialInitialized );
	}

	__forceinline int& m_iItemDefinitionIndex( ) {
		return get< int >( g_entoffsets.m_iItemDefinitionIndex );
	}

	__forceinline EHANDLE& m_hThrower( ) {
		return get< EHANDLE >( g_netvars.get( HASH( "DT_BaseCSGrenadeProjectile" ), HASH( "m_hThrower" ) ) );
	}

	__forceinline int& m_iClip1( ) {
		return get< int >( g_entoffsets.m_iClip1 );
	}

	__forceinline int& m_iPrimaryReserveAmmoCount( ) {
		return get< int >( g_entoffsets.m_iPrimaryReserveAmmoCount );
	}

	__forceinline int& m_Activity( ) {
		return get< int >( g_entoffsets.m_Activity );
	}

	__forceinline float& m_fFireDuration( ) {
		return get< float >( g_entoffsets.m_fFireDuration );
	}

	__forceinline int& m_iBurstShotsRemaining( ) {
		return get< int >( g_entoffsets.m_iBurstShotsRemaining );
	}

	__forceinline float& m_flNextPrimaryAttack( ) {
		return get< float >( g_entoffsets.m_flNextPrimaryAttack );
	}

	__forceinline float& m_flNextSecondaryAttack( ) {
		return get< float >( g_entoffsets.m_flNextSecondaryAttack );
	}

	__forceinline float& m_flThrowStrength( ) {
		return get< float >( g_entoffsets.m_flThrowStrength );
	}

	__forceinline float& m_fNextBurstShot( ) {
		return get< float >( g_entoffsets.m_fNextBurstShot );
	}

	__forceinline int& m_zoomLevel( ) {
		return get< int >( g_entoffsets.m_zoomLevel );
	}

	__forceinline float& m_flRecoilIndex( ) {
		return get< float >( g_entoffsets.m_flRecoilIndex );
	}

	__forceinline int& m_weaponMode( ) {
		return get< int >( g_entoffsets.m_weaponMode );
	}

	__forceinline int& m_nFallbackPaintKit( ) {
		return get< int >( g_entoffsets.m_nFallbackPaintKit );
	}

	__forceinline int& m_nFallbackStatTrak( ) {
		return get< int >( g_entoffsets.m_nFallbackStatTrak );
	}

	__forceinline int& m_nFallbackSeed( ) {
		return get< int >( g_entoffsets.m_nFallbackSeed );
	}

	__forceinline float& m_flFallbackWear( ) {
		return get< float >( g_entoffsets.m_flFallbackWear );
	}

	__forceinline int& m_iViewModelIndex( ) {
		return get< int >( g_entoffsets.m_iViewModelIndex );
	}

	__forceinline int& m_iWorldModelIndex( ) {
		return get< int >( g_entoffsets.m_iWorldModelIndex );
	}

	__forceinline int& m_iAccountID( ) {
		return get< int >( g_entoffsets.m_iAccountID );
	}

	__forceinline int& m_iItemIDHigh( ) {
		return get< int >( g_entoffsets.m_iItemIDHigh );
	}

	__forceinline int& m_iEntityQuality( ) {
		return get< int >( g_entoffsets.m_iEntityQuality );
	}

	__forceinline int& m_OriginalOwnerXuidLow( ) {
		return get< int >( g_entoffsets.m_OriginalOwnerXuidLow );
	}

	__forceinline int& m_OriginalOwnerXuidHigh( ) {
		return get< int >( g_entoffsets.m_OriginalOwnerXuidHigh );
	}

	__forceinline bool& m_bPinPulled( ) {
		return get< bool >( g_entoffsets.m_bPinPulled );
	}

	__forceinline float& m_fThrowTime( ) {
		return get< float >( g_entoffsets.m_fThrowTime );
	}

	__forceinline EHANDLE& m_hWeapon( ) {
		return get< EHANDLE >( g_entoffsets.m_hWeapon );
	}

	__forceinline EHANDLE& m_hWeaponWorldModel( ) {
		return get< EHANDLE >( g_entoffsets.m_hWeaponWorldModel );
	}

	__forceinline EHANDLE& m_hOwnerEntity( ) {
		return get< EHANDLE >( g_entoffsets.m_hOwnerEntity );
	}

	__forceinline float& m_flConstraintRadius( ) {
		return get< float >( g_entoffsets.m_flConstraintRadius );
	}

	__forceinline float& m_fLastShotTime( ) {
		return get< float >( g_entoffsets.m_fLastShotTime );
	}

	__forceinline bool IsGrenade( ) {
		return m_iItemDefinitionIndex( ) >= FLASHBANG && m_iItemDefinitionIndex( ) <= FIREBOMB;
	}

	__forceinline bool IsGun( ) {
		if( !this )
			return false;

		int id = m_iItemDefinitionIndex( );
		if( !id )
			return false;

		if( IsKnife( ) || IsGrenade( ) )
			return false;
		else
			return true;
	}

	__forceinline bool isShotgun( ) {
		int WeaponId = this->m_iItemDefinitionIndex( );
		return WeaponId == XM1014 || WeaponId == NOVA || WeaponId == SAWEDOFF || WeaponId == MAG7;
	}

	__forceinline bool DTable( ) {
		int WeaponId = m_iItemDefinitionIndex( );
		return IsGun( ) && !isShotgun( ) && WeaponId != SSG08 && WeaponId != AWP && WeaponId != REVOLVER && WeaponId != ZEUS;
	}

public:
	enum indices : size_t {
		SETMODELINDEX = 75,
		GETMAXCLIP1 = 368,
		GETSPREAD = 439,
		GETWPNDATA = 446, // C_WeaponCSBaseGun::GetCSWpnData
		GETINACCURACY = 469,
		UPDATEACCURACYPENALTY = 470,
	};

public:
	// virtuals.
	__forceinline int GetMaxClip1( ) {
		return util::get_method< int( __thiscall* )( void* ) >( this, GETMAXCLIP1 )( this );
	}

	__forceinline void SetGloveModelIndex( int index ) {
		return util::get_method< void( __thiscall* )( void*, int ) >( this, SETMODELINDEX )( this, index );
	}

	__forceinline WeaponInfo* GetWpnData( ) {
		return util::get_method< WeaponInfo* ( __thiscall* )( void* ) >( this, GETWPNDATA )( this );
	}

	__forceinline float GetInaccuracy( ) {
		return util::get_method< float( __thiscall* )( void* ) >( this, GETINACCURACY )( this );
	}

	__forceinline float GetSpread( ) {
		return util::get_method< float( __thiscall* )( void* ) >( this, GETSPREAD )( this );
	}

	__forceinline void UpdateAccuracyPenalty( ) {
		return util::get_method< void( __thiscall* )( void* ) >( this, UPDATEACCURACYPENALTY )( this );
	}

	// misc funcs.
	__forceinline Weapon* GetWeapon( ) {
		return g_csgo.m_entlist->GetClientEntityFromHandle< Weapon* >( m_hWeapon( ) );
	}

	__forceinline Weapon* GetWeaponWorldModel( ) {
		return g_csgo.m_entlist->GetClientEntityFromHandle< Weapon* >( m_hWeaponWorldModel( ) );
	}

	__forceinline bool IsKnife( ) {
		return ( GetWpnData( )->m_weapon_type == WEAPONTYPE_KNIFE && m_iItemDefinitionIndex( ) != ZEUS );
	}

	__forceinline float max_speed( ) {
		const auto wdata = GetWpnData( );

		if( !wdata )
			return 260.0f;

		if( g_cl.m_local->m_bIsScoped( ) )
			return wdata->m_max_player_speed_alt;

		return wdata->m_max_player_speed;
	}

	__forceinline vec3_t CalculateSpread( int seed, float inaccuracy, float spread, bool revolver2 = false ) {
		WeaponInfo* wep_info;
		int        item_def_index;
		float      recoil_index, r1, r2, r3, r4, s1, c1, s2, c2;

		// if we have no bullets, we have no spread.
		wep_info = GetWpnData( );
		if( !wep_info || !wep_info->m_bullets )
			return {};

		// get some data for later.
		item_def_index = m_iItemDefinitionIndex( );
		recoil_index = m_flRecoilIndex( );

		// seed randomseed.
		g_csgo.RandomSeed( seed/*( seed & 0xff ) + 1*/ );

		// generate needed floats.
		r1 = g_csgo.RandomFloat( 0.f, 1.f );
		r2 = g_csgo.RandomFloat( 0.f, math::pi_2 );

		// todo - dex; need to make sure this is right for shotguns still.
		//             the 3rd arg to get_shotgun_spread is actually using the bullet iterator
		//             should also probably check for if the weapon is a shotgun, but it seems like GetShotgunSpread modifies some the r1 - r4 vars...
		// for( int i{}; i < wep_info->m_bullets; ++i )
		/*
			// shotgun shit, or first bullet
			if ( !bullet_i
			  || ((int (__thiscall *)(void ***))weapon_accuracy_shotgun_spread_patterns[13])(&weapon_accuracy_shotgun_spread_patterns) )
			{
			  r1 = RandomFloat(0, 0x3F800000);// rand 0.f, 1.f
			  r2 = RandomFloat(0, 0x40C90FDB);// rand 0.f, pi * 2.f
			  v47 = *(_DWORD *)v45;
			  r2_ = r2;
			  v48 = (*(int (__thiscall **)(int))(v47 + 48))(v45);

			  // not revolver?
			  if ( v48 != sub_101D9B10(&dword_14FA0DE0) || a7 != 1 )
			  {

				// not negev?
				v50 = (*(int (__thiscall **)(int))(*(_DWORD *)v45 + 48))(v45);
				if ( v50 != sub_101D9B10(&dword_14FA0DEC) || recoil_index >= 3.0 )
				{
				  r1_ = r1;
				}
				else
				{
				  r1__ = r1;
				  recoil_index_it1 = 3;
				  do
				  {
					--recoil_index_it1;
					r1__ = r1__ * r1__;
				  }
				  while ( (float)recoil_index_it1 > recoil_index );
				  r1_ = 1.0 - r1__;
				}
			  }
			  else
			  {
				r1_ = 1.0 - (float)(r1 * r1);
			  }

			  // some convar stuff / etc
			  if ( max_inaccuracy )
				r1_ = 1.0;

			  bullet_i = v87;
			  bullet_i1 = r1_ * v104;

			  if ( only_up_is_not_0 )
				v53 = 1.5707964;
			  else
				v53 = r2_;

			  r2_ = v53;
			}

			if ( ((int (__thiscall *)(void ***))weapon_accuracy_shotgun_spread_patterns[13])(&weapon_accuracy_shotgun_spread_patterns) )
			{
			  null0 = v54;
			  m_iItemDefinitionIndex = (**(int (***)(void))LODWORD(v88))();
			  get_shotgun_spread(
				m_iItemDefinitionIndex,
				null0,
				bullet_i + m_BulletsPerShot * (signed int)recoil_index,
				&r4,
				&r3);
			}
			else
			{
			  r3 = RandomFloat(0, 0x3F800000);// rand 0.f, 1.f
			  r4 = RandomFloat(0, 0x40C90FDB);// rand 0.f, pi * 2.f
			}
		*/

		if( /*wep_info->m_weapon_type == WEAPONTYPE_SHOTGUN &&*/ g_csgo.weapon_accuracy_shotgun_spread_patterns->GetInt( ) > 0 )
			g_csgo.GetShotgunSpread( item_def_index, 0, 0 /*bullet_i*/ + wep_info->m_bullets * recoil_index, &r4, &r3 );

		else {
			r3 = g_csgo.RandomFloat( 0.f, 1.f );
			r4 = g_csgo.RandomFloat( 0.f, math::pi_2 );
		}

		// revolver secondary spread.
		if( item_def_index == REVOLVER && revolver2 ) {
			r1 = 1.f - ( r1 * r1 );
			r3 = 1.f - ( r3 * r3 );
		}

		// negev spread.
		else if( item_def_index == NEGEV && recoil_index < 3.f ) {
			for( int i{ 3 }; i > recoil_index; --i ) {
				r1 *= r1;
				r3 *= r3;
			}

			r1 = 1.f - r1;
			r3 = 1.f - r3;
		}

		// get needed sine / cosine values.
		c1 = std::cos( r2 );
		c2 = std::cos( r4 );
		s1 = std::sin( r2 );
		s2 = std::sin( r4 );

		// calculate spread vec3_t.
		return {
			( c1 * ( r1 * inaccuracy ) ) + ( c2 * ( r3 * spread ) ),
			( s1 * ( r1 * inaccuracy ) ) + ( s2 * ( r3 * spread ) ),
			0.f
		};
	}

	__forceinline vec3_t CalculateSpread( int seed, bool revolver2 = false ) {
		return CalculateSpread( seed, GetInaccuracy( ), GetSpread( ), revolver2 );
	}

	__forceinline std::string GetLocalizedName( ) {
		C_EconItemView* item_view;
		CEconItemDefinition* item_def;

		item_view = g_csgo.GetEconItemView( this );
		if( !item_view )
			return XOR( "error" );

		item_def = g_csgo.GetStaticData( item_view );
		if( !item_def )
			return XOR( "error" );

		return util::WideToMultiByte( g_csgo.m_localize->Find( item_def->GetItemBaseName( ) ) );
	}
};

class CTraceFilterSimple_game {
public:
	void* m_vmt;
	const Entity* m_pass_ent1;
	int             m_collision_group;
	ShouldHitFunc_t m_shouldhit_check_fn;

public:
	__forceinline CTraceFilterSimple_game( ) :
		m_vmt{ g_csgo.CTraceFilterSimple_vmt.as< void* >( ) },
		m_pass_ent1{},
		m_collision_group{},
		m_shouldhit_check_fn{} {}

	__forceinline CTraceFilterSimple_game( const Entity* pass_ent1, int collision_group = COLLISION_GROUP_NONE, ShouldHitFunc_t shouldhit_check_fn = nullptr ) :
		m_vmt{ g_csgo.CTraceFilterSimple_vmt.as< void* >( ) },
		m_pass_ent1{ pass_ent1 },
		m_collision_group{ collision_group },
		m_shouldhit_check_fn{ shouldhit_check_fn } {}

	__forceinline bool ShouldHitEntity( Entity* entity, int contents_mask ) {
		// note - dex; game is dumb, this gets the real vmt.
		void* real_vmt = *( void** )m_vmt;

		return util::get_method< bool( __thiscall* )( void*, Entity*, int ) >( real_vmt, 0 )( real_vmt, entity, contents_mask );
	}

	// note - dex; don't really care about calling the virtuals for these two functions, they only set members in the class for us.
	__forceinline void SetPassEntity( Entity* pass_ent1 ) {
		m_pass_ent1 = pass_ent1;

		// util::get_method< void (__thiscall *)( void *, Entity* ) >( m_vmt, 2 )( m_vmt, pass_ent1 );
	}

	__forceinline void SetCollisionGroup( int collision_group ) {
		m_collision_group = collision_group;

		// util::get_method< void (__thiscall *)( void *, int ) >( m_vmt, 3 )( m_vmt, collision_group );
	}
};

class CTraceFilterSkipTwoEntities_game {
public:
	void* m_vmt;
	const Entity* m_pass_ent1;
	int             m_collision_group;
	ShouldHitFunc_t m_shouldhit_check_fn;
	const Entity* m_pass_ent2;

public:
	__forceinline CTraceFilterSkipTwoEntities_game( ) :
		m_vmt{ g_csgo.CTraceFilterSkipTwoEntities_vmt.as< void* >( ) },
		m_pass_ent1{},
		m_collision_group{},
		m_shouldhit_check_fn{},
		m_pass_ent2{} {}

	__forceinline CTraceFilterSkipTwoEntities_game( const Entity* pass_ent1, const Entity* pass_ent2, int collision_group = COLLISION_GROUP_NONE, ShouldHitFunc_t shouldhit_check_fn = nullptr ) :
		m_vmt{ g_csgo.CTraceFilterSimple_vmt.as< void* >( ) },
		m_pass_ent1{ pass_ent1 },
		m_collision_group{ collision_group },
		m_shouldhit_check_fn{ shouldhit_check_fn },
		m_pass_ent2{ pass_ent2 } {}

	__forceinline bool ShouldHitEntity( Entity* entity, int contents_mask ) {
		// note - dex; game is dumb, this gets the real vmt.
		void* real_vmt = *( void** )m_vmt;

		return util::get_method< bool( __thiscall* )( void*, Entity*, int ) >( m_vmt, 0 )( m_vmt, entity, contents_mask );
	}

	// note - dex; don't really care about calling the virtuals for these two functions, they only set members in the class for us.
	__forceinline void SetPassEntity( Entity* pass_ent1 ) {
		m_pass_ent1 = pass_ent1;

		// util::get_method< void (__thiscall *)( void *, Entity* ) >( m_vmt, 2 )( m_vmt, pass_ent1 );
	}

	__forceinline void SetCollisionGroup( int collision_group ) {
		m_collision_group = collision_group;

		// util::get_method< void (__thiscall *)( void *, int ) >( m_vmt, 3 )( m_vmt, collision_group );
	}

	__forceinline void SetPassEntity2( Entity* pass_ent2 ) {
		m_pass_ent2 = pass_ent2;
		// util::get_method< void (__thiscall *)( void *, Entity* ) >( m_vmt, 4 )( m_vmt, pass_ent2 );
	}
};